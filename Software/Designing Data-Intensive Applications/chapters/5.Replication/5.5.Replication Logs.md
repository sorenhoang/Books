## **Topic 5.5 — Replication Logs**

At the core of any replication system—especially leader–follower replication—is **the replication log**. The log is the mechanism that ensures all replicas apply changes in the **exact same order**, preserving consistency across nodes. Without a replication log, followers could replay changes in different sequences, leading to divergent states and corrupted data.

This topic explains what replication logs are, how they are built, what they record, and how databases use them to guarantee consistent replication.

---

# **I. What Is a Replication Log?**

A replication log is an **ordered, append-only sequence of write operations** that represent all changes made to the database.

It is often also called:

* **Write-Ahead Log (WAL)**
* **Binary Log (binlog)**
* **Commit Log**
* **Change Log**
* **Transaction Log**
* **Oplog (MongoDB)**

Different systems use different terminology and internal formats, but the fundamental concept is the same.

A log entry represents **a write**, or part of a write transaction, that must be reproduced on followers.

---

## **Why Append-Only?**

Appending is:

* **efficient** — sequential disk writes are fast
* **durable** — no rewriting past history
* **ordered** — entries come in one global order
* **crash-safe** — incomplete writes can be detected

This ensures followers **apply writes in the same order** they occurred on the leader.

---

# **II. What Does the Log Contain?**

Logs can contain different levels of abstraction depending on the storage engine.

There are two main categories:

### **1. Physical (Binary) Logs**

* Records **low-level changes**: bytes written to data pages.
* Examples: PostgreSQL WAL, InnoDB redo logs.
* Intended for **crash recovery** and **replication**.

Example (conceptually):

```
Page 123, offset 89, write bytes [A3 11 FF]
```

Followers reproduce exact byte-level changes.

Pros:

* Fast
* Exactly reproduces leader state
* Stable format for replication

Cons:

* Not portable across different storage versions
* Hard to interpret logically

---

### **2. Logical Logs**

* Records **high-level operations**: INSERT/UPDATE/DELETE statements or row-level changes.
* Example: MySQL binlog (row format), MongoDB oplog, Debezium CDC logs.

Example:

```
INSERT INTO users(id, name) VALUES (123, 'Alice')
UPDATE accounts SET balance = balance - 50 WHERE id = 223
```

Pros:

* Portable across versions
* More flexible
* Easy to use for CDC and ETL

Cons:

* More complex to ensure deterministic replay
* Additional transformation needed

---

## **Hybrid Models**

Some systems record physical changes for storage consistency (WAL) and also logical logs for dataflow (binlog).

Example:

* InnoDB (MySQL) uses WAL internally, plus binlog for replication.
* PostgreSQL has WAL for replication and logical decoding for CDC.

---

# **III. Sequence and Ordering**

Consistency depends on followers replaying operations in **the same order**.

### **Why strict ordering matters:**

Example:

* initial value: `balance = 100`
* operations:

  * `balance = balance - 50`
  * `balance = balance + 30`

If replayed in reverse:

* wrong final state = `180` instead of `80`.

Logs therefore maintain a strict **serial history** of writes.

Even in systems with concurrent transactions, the log stores them in a **serializable commit order**.

---

# **IV. Commit Ordering and Durability**

Leader generally:

1. writes log entry
2. flushes to disk
3. applies change to in-memory state
4. (if sync) sends entry to followers
5. acknowledges client

Crash behavior:

* If crash happens after (1)+(2) but before acknowledgment → safe
* If crash happens before (2), write is rolled back on restart

This is the essence of **Write-Ahead Logging (WAL)**:

> A log record is written **before** the actual data is applied.

This ensures crash recovery restores a consistent state.

---

# **V. Log Shipping to Followers**

Follower replication is done by **shipping log entries**.

Two dominant strategies:

### **1. Log Streaming**

* Followers read live log entries as leader writes them.
* Low latency, near real-time.

Implementation mechanics:

* TCP streaming
* gRPC
* custom protocol
* replication slots (PostgreSQL)

### **2. Log Shipping**

* Leader periodically sends log segments (files).
* Followers apply them in batches.

Used in:

* physical replication
* archival systems

---

# **VI. Log Retention and Checkpointing**

Logs grow indefinitely unless truncated.

Systems keep the log until:

* followers have confirmed consumption,
* a checkpoint is taken,
* or snapshot taken.

Checkpoint:

* Writes all dirty state pages to disk
* Marks safe point in log
* Enables log truncation before checkpoint position

Benefit:

* reduces log size
* speeds recovery
* avoids replaying entire history

---

# **VII. Log Format Differences in Real Systems**

### **PostgreSQL**

* WAL: physical log
* Logical decoding layer provides logical events
* Uses **replication slots** for follower tracking

### **MySQL**

* Binlog: row-based logical log for replication
* InnoDB redo log for crash safety
* Combined model

### **MongoDB**

* Oplog: logical log of operations
* Replica sets use oplog for replication

### **Kafka**

Although not a database, Kafka stores events in an append-only log:

* clients replay logs at their own pace
* uses offsets to track position
* durable history like a log-based database

---

# **VIII. Replication Log and Consensus**

In distributed consensus systems (Raft, Paxos):

* the **log is the heart of consensus**
* each entry is replicated to a majority
* log entries are **committed** only when a quorum agrees
* followers apply committed entries in order

Consensus ensures **log consistency**, even in failures.

Raft elements:

* term numbers
* index
* commit index
* election timeout

Unlike async replication, consensus logs protect against:

* split-brain
* lost writes
* divergent histories

---

# **IX. Log-Based Recovery**

During restart:

* engine loads the snapshot/checkpoint
* replays log entries since checkpoint
* restores state to last committed entry

Physical logs:

* replay disk page changes

Logical logs:

* re-execute changes

This ensures crash recovery.

---

# **X. CDC (Change Data Capture)**

Replication logs are also used outside replication:

* ETL to data warehouse
* Event-driven architecture
* Cache invalidation
* Search indexing (Elasticsearch)
* Audit logging
* Streaming pipelines

CDC tools read from logs and publish changes as events.

Examples:

* Debezium
* Maxwell’s Daemon
* GoldenGate

Logs become **source of truth** for downstream systems.

---

# **XI. Log Position Tracking**

Each follower maintains a **log position**:

* LSN (Log Sequence Number)
* Offset
* Timestamp
* Entry ID

Leader knows which logs each follower has processed.

Follower state:

* **up-to-date**
* **lagging**
* **offline**

This enables safe truncation and snapshot management.

---

# **XII. Why Logs Enable Scalability**

Replication logs allow:

* concurrency on leader
* parallelism on followers
* replay at different speeds
* delayed consumption
* asynchronous processing

Followers are independent:

* they can pause and resume
* they can index data differently
* they can read from log for analytics

This makes logs a **universal integration mechanism**.

---

# **XIII. Key Takeaway Principle**

> **Replication logs are ordered, append-only records of database writes. They enable followers to consistently reproduce the leader’s state, guarantee correct crash recovery, and support external dataflow like CDC and streaming. Log integrity and ordering are the foundation of reliable replication.**

Without replication logs:

* followers would diverge
* crash recovery would fail
* consensus would be impossible
* dataflow would be unreliable

Logs are **the beating heart** of modern distributed databases.

