## **Topic 5.2 — Synchronous vs Asynchronous Replication**

In a leader–follower replication setup, a key decision is **how writes are propagated** from the leader to followers. The replication mode determines **when a write is considered committed**, how failure-safe the system is, and what consistency guarantees clients receive.

There are two primary models:

1. **Synchronous Replication**
2. **Asynchronous Replication**

Each comes with trade-offs in **availability, durability, performance, latency, and consistency**. Many real-world systems choose a hybrid strategy to balance these dimensions.

---

# **I. What Does “Committed” Mean in Replication?**

When a client sends a write request, the leader must make a decision:

> **At what point do we tell the client “OK, your write is stored”?**

Possibilities:

* after data is written on leader only,
* after data is replicated to one or more followers,
* after followers confirm the write is durable,
* after majority agree.

This decision defines **synchronous vs asynchronous** behavior.

---

# **II. Synchronous Replication**

### **Definition**

A write is considered successful **only after the leader and at least one follower** (or all followers) have confirmed the write.

Flow:

1. Client sends write to leader
2. Leader writes to its log
3. Leader sends replication entry to follower(s)
4. Followers confirm the write
5. Leader acknowledges client

So **client receives acknowledgment only after replication is complete**.

---

### **Advantages**

#### **1. Stronger Durability**

If leader fails immediately after responding:

* follower already has the write,
* no data loss,
* follower can be promoted safely.

#### **2. Stronger Consistency Guarantees**

Clients reading from followers can see recent writes faster.

#### **3. Safe Failover**

Promoting a follower to leader maintains a consistent view of data.

---

### **Disadvantages**

#### **1. Higher Latency**

Write latency includes:

* network round-trip to follower,
* follower’s disk write cost,
* acknowledgment delay.

A slow follower delays the whole system.

#### **2. Lower Availability**

If a synchronous follower becomes unavailable:

* leader cannot commit writes,
* system may block writes or degrade.

#### **3. Scalability Bottlenecks**

Every write must be replicated in real time.

---

### **Where It Is Used**

Synchronous replication is common when correctness and durability are critical:

* Financial systems
* Distributed SQL (CockroachDB)
* Some deployments of PostgreSQL synchronous commit
* Raft/Paxos consensus systems
* Highly consistent NoSQL clusters

Consensus protocols (like Raft) implicitly enforce synchronous replication **to a quorum**, ensuring safety over availability.

---

# **III. Asynchronous Replication**

### **Definition**

A write is considered successful **as soon as the leader writes locally**, without waiting for follower acknowledgment.

Flow:

1. Client sends write
2. Leader writes to its local log
3. Leader acknowledges client
4. Leader forwards log entry to followers **later**

Replication happens **after the commit**, in the background.

---

### **Advantages**

#### **1. Low Latency**

Fast response because leader doesn’t wait.

#### **2. Higher Availability**

Even if followers are slow or down:

* writes continue,
* leader stays available.

#### **3. Good for Geographically Distributed Systems**

Avoids high latency across regions.

---

### **Disadvantages**

#### **1. Risk of Data Loss**

If leader fails before followers receive the update:

* followers do not have the latest write,
* failover loses that write (called **replication lag loss**).

#### **2. Uncertainty During Failover**

If the leader crashes, it’s unclear which writes were replicated.

#### **3. Eventual Consistency**

Followers lag behind the leader.

* reads from follower may return stale data.

---

### **Where It Is Used**

Asynchronous replication is commonly used for:

* Read replicas (MySQL replicas)
* Analytics / reporting
* Global read distribution
* Low-latency high-throughput systems

It’s the default mode in most mainstream databases because it prioritizes **availability and performance** over strong guarantees.

Examples:

* MySQL (default)
* PostgreSQL async streaming
* MongoDB secondary replication (configurable)

---

# **IV. Semi-Synchronous Replication**

Real systems often implement a **hybrid** between strict synchronous and asynchronous modes.

Example:

* Leader waits for at least one follower,
* 2nd and 3rd followers replicate asynchronously.

Goal:

* reduce risk of data loss,
* avoid full latency cost.

This design ensures at least one safe copy exists if the leader fails, while other replicas may lag.

---

# **V. Failover Implications**

A critical scenario is when the leader fails **right after** acknowledging a write.

### **Synchronous:**

* Followers have the write,
* Promotion safe,
* No data loss.

### **Asynchronous:**

* Followers might not have the write,
* Write is **lost**,
* System appears to “rollback” from the client’s perspective.

This situation is called the **“lost update on failover” problem**.

In some environments, this is acceptable (e.g., analytics dashboards, caches). In others (money transfers), it is catastrophic.

---

# **VI. Behavior Under Network Partitions**

Replication mode also determines behavior when nodes are partitioned (split-brain risk).

### **Synchronous Cluster**

* Leader cannot commit writes without follower ack
* Ensures safety, sacrifices availability
* Aligns with **CP** model in CAP theorem

### **Asynchronous Cluster**

* Leader continues serving writes
* Risk of followers diverging
* Aligns with **AP** availability

Consistency vs availability is the core trade-off.

---

# **VII. Latency and Geographic Replication**

In geo-distributed systems:

* synchronous replication across continents = very slow writes
* asynchronous replication = fast writes but potential data loss

Therefore:

* systems often combine local synchronous replication (within region)
* plus cross-region asynchronous replication (for disaster recovery)

---

# **VIII. Quorum-Based Replication (Preview)**

Later in the chapter, we’ll see **quorum replication**, where writes must be acknowledged by a majority (N/2+1) of nodes. This is an advanced form of synchronous replication that balances safety and availability.

Consensus algorithms use this model to guarantee correctness even in failures.

---

# **IX. Practical Considerations**

Choosing replication mode depends on:

| Factor             | Influence                               |
| ------------------ | --------------------------------------- |
| Latency tolerance  | synchronous increases latency           |
| Consistency needs  | synchronous provides strong consistency |
| Failure tolerance  | synchronous protects against data loss  |
| Geo-distribution   | asynchronous preferred                  |
| Traffic volume     | asynchronous scales better              |
| Safety criticality | synchronous required                    |

Large systems often **mix modes**, prioritizing different trade-offs based on the business domain.

---

# **X. Key Concept Summary**

| Mode         | ACK Timing              | Data Loss Risk | Consistency | Availability |
| ------------ | ----------------------- | -------------- | ----------- | ------------ |
| Synchronous  | After followers confirm | Very low       | Strong      | Lower        |
| Asynchronous | After leader only       | Higher         | Eventual    | Higher       |
| Semi-sync    | After one follower      | Moderate       | Medium      | Medium       |

You cannot have:

* zero latency,
* zero data loss,
* high availability,
* strong consistency

**all at the same time**.

Systems must choose based on practical priorities.

---

# **XI. Key Takeaway Principle**

> **Synchronous replication waits for followers before acknowledging a write, providing strong durability and consistent failover—but at the cost of latency and availability. Asynchronous replication responds immediately, improving performance and uptime but risking data loss during leader failure.**

Understanding this trade-off is crucial for designing resilient distributed systems.