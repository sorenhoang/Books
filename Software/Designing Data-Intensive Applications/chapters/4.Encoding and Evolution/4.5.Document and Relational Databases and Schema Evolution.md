## **Topic 4.5 — Document and Relational Databases and Schema Evolution **
Schema evolution applies not only to serialized data formats but also to how databases manage changes in structure over time. Unlike encoded messages or files, databases store persistent, mutable records, and applications rely on their structure to query, validate, and interpret data. As requirements change, the structure of stored data must evolve — whether that structure is strictly defined (as in relational databases) or flexible (as in document databases).

This topic compares how relational and document databases approach schema definition, storage structure, backward/forward compatibility, and evolution patterns.

---

### **Schema in Relational Databases**

Relational databases enforce a **strict, predefined schema**. Before inserting or updating data, the structure must match column definitions, types, and constraints.

Examples of constraints:

* Data types (INT, VARCHAR, TIMESTAMP)
* Primary keys, foreign keys
* NOT NULL constraints
* Uniqueness rules

This approach ensures integrity and predictability but requires careful schema evolution planning.

---

#### **Schema Evolution in Relational Systems**

When requirements change, the schema must be modified using migrations (DDL changes):

```sql
ALTER TABLE users ADD COLUMN phone_number TEXT;
```

Relational schema changes require coordinated evolution across:

* Application code
* Database structure
* Stored data

This introduces operational complexity, especially if the database contains terabytes or billions of records.

---

#### **Migration Strategies in Relational Systems**

Common approaches:

| Strategy                          | Description                                                 |
| --------------------------------- | ----------------------------------------------------------- |
| **Online schema migration**       | Apply schema changes without downtime (common in cloud DBs) |
| **Dual-read / dual-write phases** | Application supports both old and new schema temporarily    |
| **Lazy backfill**                 | Data updated gradually over time                            |
| **Full table rewrite**            | Expensive but required for some schema changes              |

Modern systems (e.g., PostgreSQL with `ALTER TABLE` improvements) reduce risk, but relational migrations must still be done carefully.

---

#### **Advantages of Relational Schema Enforcement**

* Strong validation and business rule enforcement
* Clear data contract
* Query optimizers benefit from well-defined structure
* Reduced ambiguity for application logic

This makes relational databases ideal for **transactional systems with strong consistency and correctness requirements**.

---

### **Schema in Document Databases**

Document databases (MongoDB, Couchbase, Firebase Firestore) store **semi-structured JSON-like documents**, often without enforcing a rigid schema.

Example stored document:

```json
{
  "id": 123,
  "name": "Alice",
  "address": { "street": "Main St", "zip": 94043 },
  "tags": ["premium", "beta"]
}
```

Different records in the same collection may have different fields — a concept called **schema flexibility**.

---

#### **Schema Evolution in Document Databases**

Document databases support **gradual evolution**:

* New documents may include new fields
* Old documents remain valid with missing fields
* Application code handles missing or unknown fields gracefully

This eliminates the need for strict migration steps and allows incremental data model changes.

---

#### **Risks of Schema-Less Design (Schema Drift)**

Without discipline, the absence of enforced structure can lead to:

* Inconsistent field names (`zipcode`, `zip_code`, `zipCode`)
* Mixed data types (`age`: string or number)
* Missing required attributes in legacy records

Schema drift makes querying, analytics, and data governance harder.

To mitigate this, organizations adopt:

* JSON schema validation
* Application-level enforcement
* Automated constraints (e.g., MongoDB schema validators)

---

### **Hybrid Approach — Schema-on-Write vs Schema-on-Read**

| Model               | When Schema Applies               | Examples                               |
| ------------------- | --------------------------------- | -------------------------------------- |
| **Schema-on-Write** | Data must conform before storage  | Relational DBs, Protobuf-based writing |
| **Schema-on-Read**  | Data validated only when accessed | Document DBs, data lakes, Avro/Kafka   |

Schema-on-read allows flexibility but shifts validation responsibility to consuming applications.

---

### **Evolution Tolerance and Backward Compatibility**

| Database Type | Backward Compatibility          | Forward Compatibility                 |
| ------------- | ------------------------------- | ------------------------------------- |
| Relational    | Hard — DB must change first     | Possible with optional fields or NULL |
| Document      | Easy — missing fields tolerated | Often natural due to flexible records |

Document models embrace gradual change; relational models require contract enforcement.

---

### **Handling Changes Over Time: Examples**

#### Adding a field:

* **Relational:** Must run `ALTER TABLE`; default values must be set.
* **Document:** Just start writing new documents with the field.

#### Renaming a field:

* **Relational:** Requires data rewrite or aliasing.
* **Document:** Application supports both names until deprecated.

#### Removing a field:

* **Relational:** Must modify schema and purge data.
* **Document:** Old records simply omit the field.

---

### **Governance and Reality: Both Need Schema Discipline**

Even document databases operate best with **implicit or explicit schemas**, especially when:

* There are multiple services writing to the same collection.
* Data must be queried for analytics.
* Compliance, governance, and auditing requirements exist.

Relational databases enforce structure at the storage layer; document databases often enforce it at the application or validation layer.

---

### **Key Principle**

Both relational and document systems must deal with schema evolution — they just approach it differently.

* **Relational model = enforce schema upfront (strict consistency).**
* **Document model = allow flexibility and evolve schema incrementally.**

The right choice depends on the balance between **consistency, flexibility, governance, and operational complexity**.