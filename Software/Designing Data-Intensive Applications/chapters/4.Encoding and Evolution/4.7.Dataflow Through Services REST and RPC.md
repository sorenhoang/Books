## **Topic 4.7 — Dataflow Through Services: REST and RPC**

When systems communicate through services rather than shared databases, data flows across explicitly defined boundaries via **API calls**. This model improves modularity, ownership, scalability, and evolution because services become independent deployable units rather than tightly coupled consumers of the same database schema.

There are two major styles of service-based communication:

1. **REST (Representational State Transfer)**
2. **RPC (Remote Procedure Call)**

Both achieve the same purpose—communication between systems—but with different philosophies, trade-offs, and operational behavior.

---

## **Why Service-Based Communication Exists**

Service-based dataflow solves key issues of shared databases:

* Avoids schema coupling
* Allows individual service autonomy
* Enables independent scaling and deployment
* Establishes clear ownership of state and logic
* Encapsulates business rules behind an API boundary

This aligns with microservice principles and modern distributed architectures.

---

## **REST — Resource-Oriented Communication**

REST treats systems as collections of **resources** that can be created, read, updated, or deleted using standard HTTP verbs.

Example:

```
GET /users/123
POST /orders
PATCH /profiles/123
```

REST systems typically use:

* **JSON** (most common)
* **XML** (legacy or specialized)
* **HAL / JSON:API / OpenAPI** for metadata and discoverability

### **Characteristics of REST**

| Property       | Behavior                                      |
| -------------- | --------------------------------------------- |
| Coupling       | Loose — consumer depends only on public API   |
| Contract Style | Based on resource semantics                   |
| Protocol       | Usually HTTP/HTTPS                            |
| Data Model     | Often schema-flexible (JSON)                  |
| Evolution      | Non-breaking changes possible with versioning |

REST is intentionally simple and flexible—favoring ease of integration and interoperability.

---

### **Advantages of REST**

* Human-readable payloads (JSON)
* Well suited for public APIs (web, mobile)
* Language and platform agnostic
* Supports caching (HTTP cache, CDN, etc.)
* Loose coupling between clients and servers

---

### **Weaknesses of REST**

* No strong type system by default
* Over-fetching and under-fetching of data common (GraphQL attempts to fix this)
* Latency from multiple round-trips in complex workflows

---

## **RPC — Procedure or Function-Oriented Communication**

RPC treats communication as calling a function on a remote machine as if it were local:

```
CreateOrder(user_id, product_id, quantity)
```

Rather than dealing with resources, RPC describes explicit actions.

RPC frameworks include:

* **gRPC (Google)**
* **Apache Thrift**
* **Protocol Buffers (underlying schema)**
* **JSON-RPC**
* **SOAP (older enterprise RPC)**

RPC systems generally use **binary formats** for speed and compactness.

---

### **Characteristics of RPC**

| Property       | Behavior                                             |
| -------------- | ---------------------------------------------------- |
| Coupling       | Tighter — interaction mimics function call semantics |
| Contract Style | IDL (Interface Definition Language)                  |
| Protocol       | gRPC uses HTTP/2, others vary                        |
| Data Model     | Strong schema enforcement (Protobuf/Thrift)          |
| Evolution      | Controlled via schema versioning                     |

RPC aligns well with internal microservice communication where speed matters.

---

### **Advantages of RPC**

* Very fast and compact encoding
* Strong typing and code generation
* Efficient streaming support (especially gRPC)
* Predictable interface semantics

---

### **Weaknesses of RPC**

* Less human-readable compared to REST
* Harder debugging without tooling
* More coupling risk if not versioned carefully
* Requires schema governance and tooling

---

## **REST vs RPC: When to Use Each**

| Factor                 | REST        | RPC                 |
| ---------------------- | ----------- | ------------------- |
| Public APIs            | ✔ Best      | Rarely used         |
| Internal microservices | Good        | ✔ Best              |
| Human readability      | ✔ Strong    | Poor                |
| Performance            | Moderate    | ✔ Fast              |
| Streaming support      | Limited     | ✔ Native (gRPC)     |
| Schema flexibility     | Weak (JSON) | ✔ Strong (Protobuf) |

REST is better for open, loosely coupled ecosystems; RPC is better for tightly controlled internal interactions requiring efficiency.

---

## **Versioning and Schema Evolution**

### REST:

* Supports evolution via:

  * Optional fields
  * `V2` URLs
  * Content negotiation
* Consumers tolerate missing or new fields

### RPC:

* Schema versioning enforced via:

  * Numeric field tags (Protobuf)
  * Compatibility rules
  * Optional vs required fields

RPC requires more discipline but provides stronger guarantees.

---

## **Synchronous vs Asynchronous Behavior**

Both REST and RPC are typically **synchronous request-response**, meaning:

* Client waits for server response
* Errors propagate upstream
* Cascading failures are possible

To mitigate this, systems adopt:

* Timeouts
* Retries with idempotency
* Circuit breakers (e.g., Hystrix pattern)
* Bulkheads and backpressure

Some RPC frameworks also support **bidirectional streaming** (e.g., gRPC streaming).

---

## **Security and Governance**

Service-based dataflow requires explicit boundary policies:

* Authentication/authorization
* API gateways
* Rate limiting and quota enforcement
* Observability (logging, tracing, metrics)

These become essential in large distributed systems.

---

## **Key Principle**

REST and RPC represent two different philosophies of integration:

* **REST → Resources, loose boundaries, flexible, widely interoperable**
* **RPC → Functions, strong typing, efficient communication, internal performance**

The choice depends on system architecture, evolution requirements, coupling tolerance, and performance needs.
