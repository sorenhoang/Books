# **Transmitting Event Streams**

In the context of stream processing, input is generally treated as an **event stream** rather than a static file. An **event** is a small, self-contained, immutable object containing details of something that happened at a specific point in time, usually containing a timestamp. These events are generated by a **producer** (or publisher) and processed by multiple **consumers** (or subscribers), with related events grouped together into a **topic** or stream.

To facilitate low-latency delivery of these events without the overhead of polling a database, **messaging systems** are widely used,. These systems generally fall into two categories: direct messaging and message brokers.

### **1. Direct Messaging**

Direct messaging systems rely on direct network communication between producers and consumers without intermediate nodes. Examples include:

* **UDP Multicast:** Used in financial industries for low-latency stock feeds.
* **Brokerless Libraries:** Tools like ZeroMQ implement publish/subscribe over TCP or IP multicast.
* **Webhooks:** A producer makes a direct HTTP request to a callback URL registered by a consumer.

These systems generally require application code to handle message loss and assume producers and consumers are constantly online; if a consumer is offline, it may miss messages sent during that time,.

### **2. Message Brokers**

A **message broker** (or message queue) is a centralized server that producers write to and consumers read from. By centralizing the data, brokers can handle clients that connect and disconnect, and they manage the durability of messages (keeping them in memory or writing to disk).

* **Handling Load:** If producers send messages faster than consumers can process them, the broker can drop messages, buffer them in a queue, or apply **backpressure** (blocking the producer).
* **Patterns:** Brokers support **load balancing** (delivering a message to one of several consumers to share work) and **fan-out** (delivering a message to all consumers).
* **Acknowledgments:** To ensure messages are not lost if a consumer crashes, brokers use acknowledgments. However, redelivering unacknowledged messages can lead to reordering,.
* **Transient Nature:** Unlike databases, traditional message brokers (like JMS/AMQP standards) delete messages once they are successfully acknowledged.

### **3. Partitioned Logs (Log-Based Message Brokers)**

Log-based message brokers, such as **Apache Kafka** and **Amazon Kinesis Streams**, combine the durable storage approach of databases with the low-latency notifications of messaging,.

* **Structure:** A producer sends a message by appending it to the end of a log. To scale, the log is **partitioned** across different machines.
* **Consumer Offsets:** Within a partition, every message has a monotonically increasing sequence number (offset). Instead of tracking individual acknowledgments, the broker simply records the **consumer offset**, which indicates that all prior messages have been processed,.
* **Disk Usage:** The log effectively implements a **circular buffer** on disk. Old messages are eventually deleted or archived to reclaim space, but the buffer is typically large enough to hold days or weeks of data.
* **Decoupling:** Because reading the log is non-destructive (like reading a file), consumers can read independently without affecting each other. A slow consumer does not disrupt the service for others and can catch up later,.
* **Replayability:** This approach allows for replaying old messages, enabling experimentation and easier recovery from errors, making it similar to the batch processing model.
