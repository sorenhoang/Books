## **Topic 8.4 — Knowledge, Truth, and Lies**

This topic addresses the **deepest conceptual problem in distributed systems**:

> *What can a system truly know about its own state?*

Because of **partial failures**, **unreliable networks**, and **unreliable clocks**, no node can ever have a perfectly accurate, up-to-date view of the entire system. Nodes must make decisions based on **incomplete, delayed, and possibly false information**.

This topic explains **why certainty is impossible**, how systems cope with uncertainty, and why many distributed algorithms exist to establish a limited notion of truth.

---

# **I. The Core Problem: Knowledge Is Incomplete**

In a distributed system:

* nodes only know what they have observed,
* messages may be delayed or lost,
* failures may be temporary or permanent,
* clocks are not synchronized.

Therefore:

> **No node can ever know the exact global state of the system.**

Any decision is based on **assumptions**, not facts.

---

# **II. What Is “Truth” in a Distributed System?**

There is no absolute truth. Instead, truth is:

* **relative** (depends on perspective),
* **time-dependent** (changes over time),
* **negotiated** (agreed upon by protocol),
* **approximate** (bounded by uncertainty).

Truth in distributed systems is not discovered—it is **constructed**.

---

# **III. The Problem of Failure Detection**

Consider a node that stops responding.

Possible explanations:

* node crashed,
* node is slow,
* node is overloaded,
* network partition,
* GC pause,
* message delay.

There is no way to distinguish these with certainty.

Thus:

> **Failure detectors can never be perfect.**

They can only be:

* *eventually accurate*,
* *probabilistic*,
* *heuristic-based*.

---

# **IV. Lies, False Beliefs, and Stale Knowledge**

Because information is delayed, nodes may hold **false beliefs**:

* believing a node is alive when it’s dead,
* believing a node is dead when it’s alive,
* believing one node is leader while another believes itself leader.

These are not bugs—they are inevitable.

Distributed systems must be designed to **survive false beliefs**.

---

# **V. Split-Brain: Conflicting Truths**

Classic scenario:

* network partition divides cluster,
* both sides believe the other side is down,
* both sides elect a leader.

Now:

* two leaders exist,
* both believe they are the truth.

This is **split-brain**.

Without safeguards:

* data corruption occurs,
* conflicting writes diverge permanently.

---

# **VI. Consensus: Manufacturing Truth**

Because absolute truth is impossible, systems use **consensus protocols** to *agree* on a shared truth.

Consensus answers questions like:

* Who is the leader?
* Which value was committed?
* What is the current configuration?

Protocols:

* Paxos
* Raft
* Zab

Consensus provides:

* a single agreed-upon history,
* safety (no two nodes decide differently),
* liveness (eventual progress, under assumptions).

Consensus is how distributed systems **manufacture certainty from uncertainty**.

---

# **VII. Quorums: Majority as Truth**

Many systems define truth as:

> **Whatever a majority agrees on**

Example:

* 3 replicas: quorum = 2
* If 2 agree → decision stands

Why this works:

* two majorities must overlap,
* conflicting decisions cannot both reach quorum.

Quorums provide:

* safety under partial failures,
* tolerance of minority partitions.

But:

* minority side becomes unavailable.

---

# **VIII. Leader Election and Truth**

Leader election is a special case of consensus.

Key requirements:

* only one leader at a time,
* leader must be recognized by others,
* old leaders must step down safely.

Because of uncertainty:

* nodes may temporarily disagree about leadership,
* fencing tokens or epochs are required to prevent old leaders from acting.

Leadership is **leased**, not permanent truth.

---

# **IX. Epochs, Terms, and Fencing Tokens**

To manage stale knowledge, systems attach **monotonic counters**:

* epoch
* term
* generation number
* fencing token

Rules:

* higher epoch overrides lower epoch,
* operations with stale epochs are rejected.

Used in:

* Raft terms
* ZooKeeper zxid
* Kafka controller epoch
* Spanner timestamps

This prevents:

* zombie leaders,
* stale writes,
* corruption after failover.

---

# **X. Truth Is Local, Not Global**

Each node has:

* its own local view,
* its own timeline,
* its own belief set.

Global truth emerges only when:

* nodes exchange messages,
* agreements are reached,
* protocols enforce consistency.

Even then:

* truth is temporary,
* subject to change after failures.

---

# **XI. Knowledge Over Time**

Over time, knowledge improves:

* delayed messages arrive,
* partitions heal,
* failures become clear.

Systems rely on:

* **eventual consistency**,
* **eventual convergence**,
* **eventual accuracy**.

Immediate certainty is impossible; eventual correctness is achievable.

---

# **XII. Practical Consequences for System Design**

---

## **1. Never Assume Perfect Knowledge**

Design systems assuming:

* nodes lie,
* messages lie,
* clocks lie.

---

## **2. Design for Recovery from Wrong Decisions**

Systems must:

* detect mistakes,
* roll back,
* retry,
* reconcile.

---

## **3. Prefer Idempotency and Commutativity**

When truth is uncertain:

* duplicate actions must be safe,
* order must not matter.

---

## **4. Use Strong Coordination Only Where Necessary**

Consensus is expensive:

* use it sparingly,
* only for critical state.

---

## **5. Expect Temporary Inconsistency**

Systems must tolerate:

* inconsistent reads,
* temporary divergence,
* conflicting views.

---

# **XIII. Example: Distributed Lock Service**

If a client acquires a lock and then pauses:

* does it still hold the lock?
* has it crashed?
* should another client take over?

Without:

* leases,
* fencing tokens,
* expiration,

two clients may believe they hold the same lock.

ZooKeeper-style systems solve this by:

* time-bound leases,
* versioned ownership.

---

# **XIV. Example: Replicated Database**

During a partition:

* one side believes leader is dead,
* elects new leader,
* other side continues accepting writes.

Consensus + quorum ensures:

* only one side proceeds,
* the other becomes read-only or unavailable.

---

# **XV. Key Takeaways for Topic 8.4**

### **1. Perfect knowledge is impossible in distributed systems.**

### **2. Truth is negotiated, not discovered.**

### **3. Nodes may hold false beliefs for long periods.**

### **4. Consensus protocols manufacture shared truth.**

### **5. Quorums define truth via majority agreement.**

### **6. Epochs and fencing tokens prevent stale actors from causing damage.**

### **7. Systems must tolerate lies and recover from wrong assumptions.**

---

### **One-Sentence Summary**

> **In distributed systems, no node can know the full truth; instead, systems must tolerate uncertainty, survive false beliefs, and use consensus and quorums to construct a temporary, agreed-upon version of reality.**