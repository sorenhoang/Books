## **Topic 8.3 — Unreliable Clocks**

Time seems simple on a single machine, but in distributed systems **time is unreliable, inconsistent, and misleading**. Clocks drift, jump, disagree with each other, and sometimes move backward. Many subtle and severe bugs arise when systems assume clocks are accurate or synchronized.

This topic explains **why clocks are unreliable**, **how this breaks distributed systems**, and **how modern systems cope with time uncertainty**.

---

# **I. Why Clocks Matter in Distributed Systems**

Distributed systems use time for many purposes:

* ordering events
* setting timeouts
* determining data freshness
* assigning timestamps to transactions
* resolving conflicts
* expiring caches and leases
* leader election

If clocks are wrong, **decisions based on time are wrong**.

---

# **II. Types of Clocks**

There are two fundamentally different notions of time in systems.

---

## **1. Wall-Clock Time (Physical Time)**

Examples:

* Unix epoch time (`System.currentTimeMillis`)
* NTP-synchronized clocks
* Human-readable timestamps

Characteristics:

* Based on real-world time
* Can **jump forward or backward**
* Can differ between machines
* Influenced by NTP corrections, leap seconds, admin changes

Wall-clock time is **not monotonic**.

---

## **2. Monotonic Time**

Examples:

* `System.nanoTime()` (Java)
* POSIX monotonic clock

Characteristics:

* Always moves forward
* Not affected by clock adjustments
* Only meaningful relative to itself (durations)

Monotonic clocks are good for:

* measuring elapsed time,
* implementing timeouts,
* scheduling retries.

They are **not globally comparable across machines**.

---

# **III. Why Clocks Are Unreliable**

---

## **1. Clock Drift**

Hardware clocks run at slightly different speeds.

* Drift rates: ~10–100 ppm (microseconds per second)
* Over time, clocks diverge by milliseconds or seconds

Even with synchronization, clocks continuously drift apart.

---

## **2. Clock Skew**

Different machines show different times at the same moment.

Caused by:

* drift,
* network delays,
* imperfect synchronization.

Skew breaks assumptions like:

> “If event A happened before event B, A’s timestamp < B’s timestamp.”

This is often false in distributed systems.

---

## **3. Clock Jumps (Time Goes Backward)**

Wall clocks may jump due to:

* NTP corrections,
* leap seconds,
* manual admin changes,
* VM pause/resume,
* container migration.

Time going backward can:

* break ordering assumptions,
* violate uniqueness constraints,
* corrupt logs,
* cause negative timeouts.

---

## **4. Network Delay in Time Synchronization**

Time synchronization protocols (like NTP) rely on the network, which is unreliable:

* asymmetric latency,
* packet loss,
* congestion.

Thus:

* synchronization is approximate,
* uncertainty is unavoidable.

---

# **IV. Why You Cannot Rely on Wall-Clock Time for Ordering**

Example:

* Node A writes at time `10:00:05`
* Node B writes at time `10:00:03`
* In reality, B’s write happened *after* A’s

Using timestamps to order these events leads to **causal inversion**.

This causes:

* lost updates,
* incorrect conflict resolution,
* broken invariants.

---

# **V. Common Bugs Caused by Unreliable Clocks**

---

## **1. Incorrect Event Ordering**

Assuming timestamps reflect real execution order leads to:

* incorrect log ordering,
* invalid conflict resolution,
* stale data overwriting newer data.

---

## **2. Broken Time-Based Expiration**

If time jumps backward:

* TTLs may never expire,
* leases may last forever.

If time jumps forward:

* leases may expire instantly,
* sessions may be invalidated.

---

## **3. Leader Election Failures**

Using wall-clock time to decide leadership can cause:

* multiple leaders,
* premature leadership revocation,
* split brain.

---

## **4. Inconsistent Snapshots**

Databases using timestamps for MVCC may:

* expose future data,
* hide committed data,
* violate isolation guarantees.

---

# **VI. Logical Time: An Alternative**

To avoid unreliable physical clocks, distributed systems often use **logical clocks**.

---

## **1. Lamport Timestamps**

Each process keeps a counter:

* increment before each event,
* include counter in messages,
* receiver sets counter = max(local, received) + 1.

Guarantees:

* if A happened-before B → timestamp(A) < timestamp(B)

Does **not** capture concurrency (two events can have unrelated timestamps).

---

## **2. Vector Clocks**

Each node keeps a vector of counters:

* one counter per node.

Allows detection of:

* causality,
* concurrency.

Trade-offs:

* metadata size grows with number of nodes,
* expensive in large systems.

Used in:

* Dynamo-style systems,
* version vectors.

---

# **VII. Hybrid Logical Clocks (HLC)**

HLCs combine:

* physical time (wall-clock),
* logical counters (Lamport).

Properties:

* mostly follows real time,
* monotonic,
* preserves causality.

Used in:

* CockroachDB,
* YugabyteDB.

HLCs tolerate clock skew while enabling efficient ordering.

---

# **VIII. TrueTime: Bounding Uncertainty**

Some systems do not avoid physical time — they **bound its uncertainty**.

---

## **Google Spanner’s TrueTime**

TrueTime returns an interval:

```
[earliest, latest]
```

Guarantee:

> Actual time is somewhere in this interval.

By waiting out the uncertainty (commit-wait), Spanner ensures:

* external consistency,
* globally ordered transactions.

Cost:

* added latency,
* specialized clock infrastructure (GPS + atomic clocks).

---

# **IX. Time and Transactions**

Time is often used for:

* MVCC versioning,
* transaction ordering,
* snapshot isolation.

But unreliable clocks mean:

* timestamps must be validated,
* reads must tolerate uncertainty,
* commits may need waiting.

Using time safely requires:

* monotonic timestamps,
* conflict detection,
* or uncertainty bounds.

---

# **X. Best Practices for Dealing with Unreliable Clocks**

---

## **1. Never Use Wall-Clock Time for Ordering Events Across Nodes**

Use:

* logical clocks,
* vector clocks,
* consensus ordering.

---

## **2. Use Monotonic Clocks for Timeouts**

Elapsed-time measurement must not depend on wall-clock.

---

## **3. Treat Timestamps as Approximate**

Timestamps are metadata, not truth.

---

## **4. Prefer Logical or Hybrid Clocks for Distributed Coordination**

Especially for:

* conflict resolution,
* causality tracking,
* replication.

---

## **5. Assume Time Can Jump**

Design TTLs, leases, and expirations defensively.

---

# **XI. Why This Matters for System Design**

Many distributed system bugs are caused by:

* incorrect assumptions about time,
* misuse of timestamps,
* reliance on synchronized clocks.

Understanding unreliable clocks helps explain:

* why consensus protocols exist,
* why databases avoid timestamp-only ordering,
* why distributed transactions are complex.

---

# **XII. Key Takeaways for Topic 8.3**

### **1. Clocks in distributed systems are inherently unreliable.**

### **2. Wall-clock time can jump, drift, and disagree across machines.**

### **3. You cannot safely order distributed events using timestamps alone.**

### **4. Monotonic clocks are for durations, not ordering across nodes.**

### **5. Logical clocks provide causal ordering without relying on real time.**

### **6. Hybrid clocks and bounded-time systems (Spanner) carefully manage uncertainty.**

### **7. Incorrect time assumptions lead to subtle, catastrophic bugs.**

---

### **One-Sentence Summary**

> **In distributed systems, time cannot be trusted: clocks drift, jump, and disagree, so safe coordination requires logical ordering or explicit uncertainty management rather than naïve timestamp comparisons.**