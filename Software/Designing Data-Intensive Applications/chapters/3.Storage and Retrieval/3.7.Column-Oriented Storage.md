## **Topic 3.7 — Column-Oriented Storage**

Column-oriented storage is a data layout strategy where values are stored **column by column** rather than row by row. This approach is purpose-built for analytical workloads, where queries frequently scan large amounts of data and operate on specific columns instead of retrieving full records. Columnar storage is a cornerstone of modern **OLAP systems** (Online Analytical Processing), data warehouses, and analytical query engines.

Unlike row-oriented storage—used in traditional transactional databases—columnar formats optimize for aggregation, compression, and vectorized execution, enabling high read performance on large-scale datasets.

---

### **How Column-Oriented Storage Works**

In row-based systems, data is stored like this:

| id  | age | salary | country |
| --- | --- | ------ | ------- |
| 1   | 28  | 80000  | US      |
| 2   | 35  | 95000  | CA      |

Stored on disk as:

```
1,28,80000,US | 2,35,95000,CA | ...
```

In column-oriented storage, the same data is stored grouped by column:

```
id:      [1, 2]
age:     [28, 35]
salary:  [80000, 95000]
country: ["US", "CA"]
```

Each column is stored separately, often in compressed blocks.

---

### **Why This Matters**

Analytical queries often access only a subset of columns and process millions or billions of rows.

Example query:

```sql
SELECT AVG(salary) FROM employees WHERE age > 30;
```

In a row-based system, the database must read entire rows—including unused columns.

In a column-oriented system, only two columns (`age` and `salary`) are read, dramatically reducing I/O.

---

### **Advantages of Column-Oriented Storage**

#### **1. Better Compression**

Since values in a column tend to have similar types and repeated patterns, columnar storage benefits from highly efficient compression methods:

* Run-length encoding (RLE)
* Dictionary compression
* Delta encoding
* Bit-packing

Compression reduces storage size and speeds up scans because systems read less data from disk.

---

#### **2. Faster Analytics and Aggregations**

Queries like `SUM`, `AVG`, `GROUP BY`, and `COUNT` operate efficiently using:

* Vectorized execution (process many values at once)
* SIMD hardware instructions
* Pre-aggregated metadata

Column systems are built to scan billions of rows quickly.

---

#### **3. Improved I/O Efficiency**

Only relevant columns are read. This eliminates unnecessary disk access and improves caching.

---

#### **4. Modern Execution Optimizations**

Columnar systems frequently support:

* Lazy evaluation
* Predicate pushdown (filters applied before reading full data)
* Zone maps (track min/max to skip irrelevant blocks)

This makes column engines extremely fast for filtering and scanning workloads.

---

### **Disadvantages of Column-Oriented Storage**

Columnar systems are not ideal in all cases. Their main shortcomings include:

| Limitation                           | Explanation                                                         |
| ------------------------------------ | ------------------------------------------------------------------- |
| Slow writes and updates              | Modifying a single row may require rewriting multiple column blocks |
| Expensive random record retrieval    | Reassembling full rows requires reading multiple columns            |
| Higher memory cost for metadata      | Indexes, compression, and zone maps add overhead                    |
| Poor fit for transactional workloads | OLTP requires frequent row-level updates and point reads            |

Therefore, most columnar engines are used in **read-heavy analytical workloads**, often downstream from transactional systems.

---

### **Column Stores in Modern Architecture**

Columnar storage is a key component of the modern **data warehouse and lakehouse ecosystem**, powering:

* BI dashboards
* SQL analytics engines
* Machine learning preprocessing
* Time-series analytical workloads

Examples include:

| System               | Category                       |
| -------------------- | ------------------------------ |
| ClickHouse           | High-performance OLAP database |
| Amazon Redshift      | Cloud data warehouse           |
| Snowflake            | Distributed analytical engine  |
| Apache Parquet / ORC | Columnar file formats          |
| BigQuery             | Serverless columnar engine     |
| Apache Druid / Pinot | Real-time analytics            |

Many systems combine column-oriented storage with techniques like LSM-trees or distributed sharding.

---

### **Columnar File Formats and Data Lakes**

In analytical ecosystems, data may be stored in column format files such as:

* **Apache Parquet**
* **Apache ORC**
* **Feather and Arrow formats**

These are optimized for cloud data processing systems like Spark, DuckDB, Trino, and Hive.

Features include:

* Compression
* Predicate pushdown
* Schema evolution
* Block-level indexing

Columnar storage enables scalable query engines to work efficiently on distributed object storage (S3, GCS, HDFS).

---

### **Hybrid Models: OLTP + OLAP**

Some modern systems blend row and columnar storage:

* **PostgreSQL extensions (cstore_fdw)**
* **MySQL ColumnStore**
* **MariaDB ColumnStore**
* **SAP HANA**
* **TiDB / ClickHouse integrations**

Hybrid engines enable real-time operational analytics without duplicating ETL pipelines.

---

### **Key Principle**

Column-oriented storage is optimized for analytical workloads where the cost of scanning large datasets is dominant and where queries typically access a subset of columns. Compression, vectorized execution, and selective reading make columnar systems ideal for large-scale analytical query engines. However, they trade away write speed and row-level access efficiency, making them poorly suited for transactional workloads.