## **Topic 3.6 — Other Indexing Structures**

Beyond B-trees and LSM-trees, databases use a variety of additional indexing structures to improve performance for specific access patterns. No single index type fits every workload; instead, modern systems combine multiple indexing strategies to optimize lookups, range scans, full-text searches, geospatial queries, and similarity matching. These alternative data structures fill gaps and support specialized operations where general-purpose indexes are inefficient.

Indexes improve performance by reducing the amount of data the database must scan, but they add costs: extra storage, slower writes, and maintenance overhead. The choice of indexing structure reflects workload characteristics, data distribution, and query patterns.

---

### **1. Secondary Indexes**

A secondary index refers to indexing on non-primary-key fields. While primary indexes uniquely identify records, secondary indexes allow efficient filtering on other attributes, such as:

* email → user
* product_category → products
* created_at → posts

Secondary indexes may point directly to records or reference primary-key entries (clustered vs non-clustered models).

Challenges include:

* **Maintaining consistency during writes**
* **Handling non-unique values**
* **Supporting multi-index filtering (index intersection)**

Many relational systems support secondary indexes natively. Some NoSQL systems offer only primary indexes or restrict secondary indexing due to distributed complexity.

---

### **2. Multi-Dimensional Indexes**

For workloads involving multiple numeric dimensions — such as spatial or geometric data — one-dimensional indexes like B-trees are inefficient. Multi-dimensional indexes enable queries like:

* Find stores within 5 km of GPS coordinate
* Find points in a rectangular bounding box
* Spatial joins or nearest neighbor lookups

Common structures include:

* **R-Trees** (used in PostGIS, SQLite, MySQL spatial indexes)
* **Quad Trees** (used in mapping, GIS engines)
* **KD-Trees** (used in machine learning similarity search)

R-trees group nearby objects into bounding rectangles, enabling efficient range filtering and geospatial queries.

---

### **3. Full-Text Search Indexes**

Traditional indexes struggle with text searching involving stemming, tokenization, ranking, or fuzzy matching. Full-text engines use inverted indexes, which map words to documents containing them.

Example structure:

```
"database" → doc1, doc5, doc7  
"storage"  → doc2, doc5, doc8  
```

Features typically include:

* Tokenization and stopword filtering
* Frequency scoring (TF-IDF, BM25)
* Phrase matching and ranking
* Fuzzy matching / typo tolerance

Systems using inverted indexes:

* **Elasticsearch / OpenSearch**
* **Apache Lucene**
* **Solr**
* **PostgreSQL Full-Text Search**

These indexes excel for search use cases but are less suitable for structured numeric filtering.

---

### **4. Bitmap Indexes**

Bitmap indexes are efficient for **low-cardinality columns**, meaning columns with few distinct values (e.g., gender, status, region). Instead of storing row references directly, bitmap indexes store bit vectors where each bit corresponds to a row.

Example for `status: active` column:

```
Row:     1 2 3 4 5 6 7
Active:  1 0 1 0 1 1 0
```

Bitwise operations (AND, OR, XOR) enable extremely fast multi-condition filtering — ideal for analytical workloads. Bitmap indexes are widely used in columnar databases like:

* **ClickHouse**
* **Vertica**
* **Snowflake**
* **Oracle Bitmap Indexes**

They are less suitable for OLTP because frequent updates require rewriting bitmaps.

---

### **5. Bloom Filters**

A **Bloom filter** is a probabilistic data structure used to test whether a key *might exist* in a dataset. It may report false positives but never false negatives.

Used widely in:

* LSM-tree read paths (avoid unnecessary SSTable searches)
* Distributed database partition routing (Cassandra, Bigtable)
* Caches (detect cold cache misses)
* Deduplication and pre-check filtering

Bloom filters reduce disk I/O by quickly checking key existence before performing expensive lookups.

---

### **6. Trie / Prefix Indexes**

Tries (prefix trees) are specialized data structures used for indexing strings, especially when many keys share prefixes.

Examples:

* Autocomplete systems
* DNS hierarchical structures
* IP subnet routing tables

Tries support efficient prefix queries like:

```
WHERE name LIKE 'Pro%'
```

They are common in text-heavy indexing systems, compilers, and network routing engines.

---

### **7. Hash Partitioning Indexes**

In distributed systems, indexing may also occur at the **partition routing layer**, mapping a key to a shard or node using hashing or consistent hashing.

Examples:

* DynamoDB partition keys
* Cassandra vnode hashing
* Redis Cluster slot mapping

These routing indexes ensure data distribution and avoid hot partitions.

---

### **Trade-Off Overview of Index Types**

| Index Type     | Best For                     | Weakness                |
| -------------- | ---------------------------- | ----------------------- |
| B-Tree         | Range queries, ordered scans | Random writes           |
| LSM Tree       | Write-heavy workloads        | Read amplification      |
| Hash Index     | Equality lookups             | No range scans          |
| Bitmap Index   | Low cardinality filters      | Costly updates          |
| Inverted Index | Full-text search             | Heavy indexing overhead |
| R-Tree         | Geospatial data              | Complex maintenance     |
| Trie           | Prefix search                | Memory-heavy            |
| Bloom Filter   | Existence filtering          | False positives         |

No single index solves all problems — each is optimized for a narrow domain.

---

### **Key Principle**

Indexes are specialized tools. Choosing the right indexing strategy depends on understanding query patterns, write frequency, data structure, and system scale. Modern databases often combine multiple indexing structures to balance performance trade-offs across diverse workloads.