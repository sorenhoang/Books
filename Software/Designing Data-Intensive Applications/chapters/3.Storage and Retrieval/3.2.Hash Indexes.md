## **Topic 3.2 — Hash Indexes**

Hash indexes are one of the simplest and most widely used indexing methods in databases and storage systems. They map keys to values using a hash function, providing very fast lookups when querying for a specific key. The core idea is that hashes convert a lookup key (like a username or primary key) into a fixed integer value that corresponds to a slot position in a hash table. This allows retrieval in **near constant time**, typically **O(1)** on average, regardless of dataset size.

Hash indexes are extremely efficient for **equality-based queries**, such as:

* `WHERE id = 123`
* `GET user:alice`
* `Lookup session token`

Because the hash function directly maps the key to a position, the system avoids scanning or traversing large data structures. However, hash indexes are not suitable for **range queries** (e.g., `BETWEEN`, `<`, `>`, ordering queries) because they destroy natural ordering due to hashing.

---

### **How Hash Indexes Work**

A hash index consists of:

1. **A hash function** → converts a key to a numeric hash.
2. **A hash table or directory** → stores references to data locations.
3. **Collision handling mechanism** → handles cases where multiple keys produce the same hash value.

Example:

```
hash("alice") → 04219
hash("bob")   → 77110
hash("carol") → 04219 (collision)
```

When collisions occur, the database must store multiple entries in a single slot and later resolve ambiguity.

Common collision handling methods include:

* **Separate chaining** (linked lists or buckets per hash slot)
* **Open addressing** (probing alternative slots)

---

### **Use in Databases**

Databases may use hash indexes in two ways:

* **In-memory hash tables**: Fast, temporary lookup structures.
* **Persistent hash indexes**: Stored on disk or SSD with durability guarantees.

Some systems use **write-ahead logs** (WAL) for durability and reconstruct the hash index in memory during startup. Others store the hash structure persistently, designed for partial disk access during queries.

Examples:

* Redis uses an in-memory hash structure as a primary data model.
* MySQL’s MEMORY engine supports hash indexes.
* PostgreSQL supports hash indexes but B-trees are default because of broader flexibility.

---

### **Advantages of Hash Indexes**

1. **High lookup performance**
   Lookup time is effectively constant—even with millions or billions of records.

2. **Excellent for equality-based queries**
   When exact key matches are the dominant query type, hash indexes are ideal.

3. **Simple implementation**
   Compared to trees or segment-based storage, hash indexes are conceptually simple.

4. **No need to rebalance or maintain sorted structure**
   There is no tree balancing or ordered maintenance overhead.

---

### **Limitations and Trade-offs**

Despite high performance, hash indexes have limitations that make them unsuitable for some workloads:

| Limitation                                    | Explanation                                                        |
| --------------------------------------------- | ------------------------------------------------------------------ |
| **Not suitable for range queries**            | Hashing destroys ordering (`<`, `>` operations become impossible). |
| **Handling collisions impacts performance**   | Many hash collisions or uneven distribution create hotspots.       |
| **Difficult to compress or optimize storage** | Because items are spread unpredictably.                            |
| **Resize / rehash operations are expensive**  | When the table grows, rehashing can be costly.                     |
| **Not ideal for ordered scans**               | No sequential access property like in B-trees.                     |

For workloads requiring sorted traversal, prefix search, or range analytics, B-trees or LSM-based structures are preferred.

---

### **Hash Indexes in Write-Optimized Systems**

In log-structured storage engines (like LSM trees), hash indexes are often used as **in-memory lookup tables** to quickly locate records stored in immutable segments on disk. These in-memory tables are sometimes called **memtables**, **index blocks**, or **hash maps pointing to file offsets**.

After flushing data to disk segments, the hash index either:

* Is rebuilt from disk,
* Or stored as a sparse index to accelerate read paths.

Systems like **LevelDB, RocksDB, Cassandra** follow this philosophy.

---

### **Secondary Hash Indexes**

Some databases support hash indexes not just on primary keys but also secondary attributes. However, secondary hash indexing becomes tricky if attributes change frequently, requiring index updates or tombstones.

Use cases:

* Indexing email addresses for login
* Mapping user tokens in authentication systems
* Quick lookup tables for metadata

---

### **Real-World Use Cases**

Hash indexes are widely used in:

* **Caching systems** (Redis, Memcached): Key-value lookups
* **Session stores**: User token → state mappings
* **Routing tables**: Shard key → server mapping
* **In-memory lookup tables**: Query execution planning, join processing
* **LSM-based databases**: Fast in-memory indexing prior to segment compaction

They shine in scenarios involving exact match queries where speed is critical.

---

### **Key Principle**

Hash indexes excel when the dominant access pattern is equality lookup on a specific key. They provide extremely fast search capabilities, but their lack of ordering makes them unsuitable for range-based workloads. As a result, databases often combine hash indexes with other indexing structures depending on the workload.