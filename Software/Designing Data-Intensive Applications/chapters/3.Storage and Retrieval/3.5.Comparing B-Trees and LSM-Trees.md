## **Topic 3.5 — Comparing B-Trees and LSM-Trees**

B-trees and LSM-trees represent two fundamentally different philosophies for building storage engines. Both support indexing and provide mechanisms to read and write data efficiently, but they optimize for **very different workloads and hardware realities**. Understanding their trade-offs is essential when choosing the right database system or performance-tuning a storage layer.

At a high level:

* **B-trees favor read performance and predictable access patterns**, making them ideal for OLTP and structured relational workloads.
* **LSM-trees favor write throughput and sequential disk access**, making them ideal for write-heavy or log-structured systems such as modern distributed NoSQL databases.

Both models coexist in industry because no single structure is optimal for all workloads.

---

### **Core Differences in Write Strategy**

| Property            | B-Tree                    | LSM-Tree                                 |
| ------------------- | ------------------------- | ---------------------------------------- |
| Write Method        | Update in place           | Append-only                              |
| Disk I/O Type       | Random writes             | Sequential writes                        |
| Write Amplification | Moderate to high          | High (due to compaction), but sequential |
| Crash Safety        | Requires WAL / journaling | WAL + immutable segment files            |

B-trees modify existing pages on disk. Because random writes are required, performance depends heavily on disk latency and page structure.

LSM-trees avoid random writes by **buffering changes in memory** and writing sorted, immutable SSTables sequentially to disk—much faster on both HDDs and SSDs.

---

### **Read Behavior and Complexity**

Reads behave differently because LSM-trees store multiple immutable levels, meaning a key may exist in multiple files.

| Read Type    | B-Tree                   | LSM-Tree                                  |
| ------------ | ------------------------ | ----------------------------------------- |
| Point Lookup | Fast, single path lookup | May require checking multiple SSTables    |
| Range Scans  | Very efficient           | Possible but slower due to file merging   |
| Index Depth  | Fixed, balanced          | Depends on flushing and compaction layers |

LSM engines use **Bloom filters, block indexes, and caching layers** to mitigate multi-file lookups.

---

### **Compaction vs Page Splits**

* **B-trees require page balancing and splitting** during insert/delete operations to maintain structure.
* **LSM-trees require compaction (merging SSTables)** to remove outdated values, sort files, and reclaim space.

Compaction is both a strength (reduces fragmentation, compresses storage) and a vulnerability (may cause latency spikes if misconfigured).

---

### **Storage Layout and Compression**

* **LSM-trees compress better** because sorted, immutable data compresses efficiently.
* **B-trees allow fragmentation** due to in-place updates, making compression harder.

This makes LSM-trees attractive for time-series or analytical workloads storing trillions of records.

---

### **Performance Summary by Workload**

| Workload Type                            | Better Choice | Reason                                                |
| ---------------------------------------- | ------------- | ----------------------------------------------------- |
| Write-heavy workloads                    | LSM-Tree      | Sequential append writes, efficient compaction        |
| Read-heavy OLTP with point lookups       | B-Tree        | Predictable indexed lookups with low read latency     |
| Range queries                            | B-Tree        | Natural ordering                                      |
| Log ingestion, streams, time-series data | LSM-Tree      | Efficient burst writes and compaction                 |
| Large-scale distributed stores           | LSM-Tree      | Fits append-only replication and distributed sharding |

This explains why traditional SQL engines rely on B-trees, while modern NoSQL and distributed systems lean toward LSM structures.

---

### **Operational Characteristics**

| Characteristic      | B-Tree                 | LSM-Tree                                                    |
| ------------------- | ---------------------- | ----------------------------------------------------------- |
| Memory Usage        | Less RAM for indexing  | Needs memory for WAL + memtable                             |
| Latency Consistency | Stable and predictable | Can fluctuate during compaction                             |
| Disk Footprint      | Often higher           | Lower due to compression + immutability                     |
| Replication Support | Straightforward        | Often based on log shipping (aligned w/ append-only design) |

LSM-trees align naturally with **multi-leader replication and event-based architectures** (e.g., Dynamo model databases).

---

### **Effect of Hardware Trends**

Modern SSDs reduced the gap between sequential and random writes, but sequential writes (LSM) still win for durability and throughput, especially under heavy concurrency. Meanwhile, B-trees benefit from **fast random reads on SSDs**, reinforcing their use in transactional SQL systems.

---

### **Examples of Real-World Systems Using Each Structure**

#### **B-Tree-Based Engines**

* PostgreSQL
* MySQL InnoDB
* SQLite
* Oracle
* SQL Server

#### **LSM-Tree or Hybrid Engines**

* Cassandra
* LevelDB / RocksDB
* HBase
* Bigtable
* DynamoDB
* TiDB (TiKV engine)

Some modern databases (e.g., MongoDB WiredTiger) use hybrid approaches with LSM concepts internally.

---

### **When to Choose Each**

Use **B-trees** when:

* Queries rely on range scans, sorting, or indexes
* Workload is read-heavy or transactional
* Latency must remain stable and predictable

Use **LSM-trees** when:

* Write throughput is critical
* System must scale horizontally
* Data is log-structured or time-series based
* Compression and storage efficiency matter

---

### **Key Principle**

B-trees optimize for **fast, accurate reads with predictable performance**, whereas LSM-trees optimize for **high write throughput and sequential persistence**. The right choice depends on workload patterns—not on general preference.

Understanding these trade-offs helps database engineers select or tune systems based on real-world performance needs.