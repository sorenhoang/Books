## **Topic 3.1 — Data Structures That Power Databases**

At the core of every database—even those that appear abstracted from hardware—lie fundamental data structures optimized for storage, lookup, and modification. Understanding these underlying structures is essential because database behavior, performance characteristics, scalability, and trade-offs all derive from these core design choices. Databases are not magic: they are engineered around carefully chosen data structures that balance read efficiency, write efficiency, memory limits, and durability.

When data is stored on disk or SSD rather than in memory, access characteristics change dramatically. Unlike RAM, disk or flash storage is much slower and optimized for sequential rather than random access. Database storage engines are built to minimize costly random reads and writes, using structures that allow efficient lookup while preserving durability and performance. These structures make indexing, search, updates, and range queries feasible even at massive scale.

---

### **In-Memory vs On-Disk Realities**

Memory and persistent storage behave differently:

* **Memory access is fast and random-access friendly.**
* **Disk access is slow and optimized for sequential reads/writes.**
* **SSDs improve random access performance but are still slower than RAM.**

Because databases must persist data even after crashes, they can’t rely solely on in-memory structures like hash maps or tree structures—these must be adapted for disk or combined with write-ahead logs (WAL), snapshots, or checkpoint mechanisms.

This constraint shapes the design of indexing and storage engines. Structures like B-trees and Log-Structured Merge Trees (LSM-trees) arose specifically to cope with disk I/O limitations.

---

### **Key Goals of Database Storage Structures**

1. **Efficient Lookup**
   Support fast point queries (`WHERE id = ?`) and sometimes range queries (`WHERE age BETWEEN 30 AND 50`).

2. **Efficient Writes**
   Avoid rewriting large files per change; instead structure writes as incremental, sequential operations when possible.

3. **Minimize Disk Seeks**
   Because seeks are slower than sequential reads, structures are optimized to read/write in bulk rather than one record at a time.

4. **Durability and Crash Recovery**
   Structures incorporate logs, checkpoints, or immutable segments to recover safely after failures.

---

### **Types of Data Organization in Storage Engines**

Different systems adopt different strategies depending on the workload style (OLTP vs OLAP, write-heavy vs read-heavy, point lookup vs scan).

The two dominant families include:

#### **1. Log-Structured Storage Engines**

These engines treat storage as an append-only log. Instead of updating data in place, they add new versions sequentially as new entries. Old data is cleaned up later through compaction or merging.

Examples: **SSTables, LSM-Trees (Cassandra, LevelDB, RocksDB, HBase)**

Benefits:

* Very fast writes (sequential I/O)
* Efficient compression
* Immutable segments simplify crash recovery

Drawbacks:

* Reads may require merging multiple segments
* Compaction overhead can impact performance

---

#### **2. Update-In-Place Storage Engines**

These engines modify existing storage locations directly rather than appending new log entries.

Examples: **B-trees (PostgreSQL, MySQL InnoDB, Oracle DB, SQL Server)**

Benefits:

* Fast reads with predictable lookup paths
* Natural support for sorted range queries

Drawbacks:

* Writes require random disk access
* Page splitting and balancing operations introduce overhead

---

### **Why Index Structures Exist**

Without indexes, retrieving a row means scanning the entire dataset. As data scales from thousands to billions of records, this becomes unacceptable. Indexes exist to accelerate lookup by narrowing the search basedon a defined structure.

Indexes are built using carefully engineered data structures such as:

* Hash tables → efficient equality lookups
* B-trees → sorted index supporting ranges
* LSM/Segment structures → optimized for write-heavy workloads

Indexes represent a space-performance trade-off: faster reads but slower writes and more disk usage.

---

### **Write-Ahead Logs (WAL) and Durability**

Regardless of structure, most databases pair their main storage engine with a **write-ahead log**:

* Writes are appended to a log before modifying the main structure.
* Ensures data is recoverable after crashes.
* Makes writes sequential and fast.

After logging, data may be reorganized into more efficient storage formats asynchronously.

---

### **Hybrid Approaches**

Modern systems increasingly combine models:

| Component                      | Example System                | Role                          |
| ------------------------------ | ----------------------------- | ----------------------------- |
| LSM-tree + WAL                 | Cassandra, RocksDB, HBase     | Write-optimized core          |
| B-tree + log                   | PostgreSQL, InnoDB            | Balanced read/write workloads |
| Columnar + compressed segments | ClickHouse, Parquet, Redshift | Analytics workloads           |

Choice depends on workload patterns, consistency requirements, dataset size, and expected query frequency.

---

### **Key Observations**

* No single structure fits every use case — trade-offs define architecture.
* Append-only designs scale well in distributed environments.
* Update-in-place designs remain dominant in traditional relational workloads.
* Index structure impacts performance far more than query language or syntax.

---

### **Key Principle**

Database storage engines are built around data structures specifically optimized for reading, writing, persistence, and recoverability under real-world hardware constraints. Understanding these structures—rather than treating databases as black boxes—is essential for selecting, tuning, and designing data systems at scale.