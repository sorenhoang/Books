## **Topic 3.3 — SSTables and LSM-Trees**

SSTables (Sorted String Tables) and LSM-Trees (Log-Structured Merge Trees) are foundational storage structures used in modern high-write throughput databases. They were designed to address the limitations of traditional update-in-place storage models when handling large data volumes, high write rates, and distributed storage environments.

Instead of directly modifying data at its storage location, LSM-based systems write data sequentially to disk and later organize it into sorted, immutable files (SSTables). This approach minimizes random disk I/O and improves write performance, making LSM-Trees ideal for systems with heavy ingestion workloads.

This storage design is used in systems like **Cassandra, HBase, LevelDB, RocksDB, DynamoDB, TiKV, Kafka Streams**, and many modern cloud-native DB engines.

---

### **The Role of SSTables**

An **SSTable** is a file format storing key-value pairs sorted by key. Once written, an SSTable is immutable—no in-place updates occur. Instead, new data is appended and eventually merged.

An SSTable typically contains:

* Sorted key-value records
* Index for binary search
* Block or page-based structure for efficient disk access
* Bloom filters to avoid unnecessary disk lookups

Example structure:

```
+---------------------------------------------+
| Block 1 | Block 2 | Block 3 | ... | Block N |
+---------------------------------------------+
           ↑ index maps keys to block offsets
```

Because SSTables are sorted and immutable, reading via binary search is efficient, and merging multiple tables is straightforward.

---

### **Why Immutable Sorted Files Help**

Immutability enables:

* **Safe concurrent reads** (no locks required)
* **Append-only writes** (fast sequential disk access)
* **Persistence simplicity** (crash recovery via logs)
* **Efficient compression** (sorted data compresses well)

Instead of updating or deleting a record, a new overwritten version is appended. Old versions are cleaned later by **compaction**.

---

### **Write Path in LSM Trees**

LSM (Log-Structured Merge) Trees use a multi-layer approach to balance memory speed and durable storage.

#### Typical write flow:

1. **Write to Write-Ahead Log (WAL)** for durability.
2. **Insert into an in-memory balanced structure** (often a memtable backed by a skip list or red-black tree).
3. When the memtable reaches a size limit, **flush it to disk as a new SSTable**.

This means writes are fast because they’re sequential, not random.

---

### **Read Path in LSM Trees**

Since multiple SSTables may contain different versions of the same key, reads require searching across storage layers:

1. Check memory (memtable).
2. Check recently flushed SSTables.
3. Check older SSTables.

Data structures like:

* **Bloom filters** (to check if key exists without a disk read)
* **Sparse indexes**
* **Block caches**

are used to optimize read performance.

---

### **Compaction and Merging**

Over time, SSTables accumulate redundant or outdated entries (including delete markers called tombstones). To maintain read efficiency, LSM systems periodically perform **compaction**:

* Merge multiple SSTables into one
* Remove overwritten and deleted data
* Maintain sorted order and sparsity

Compaction is critical, but CPU and I/O intensive. Poorly tuned compaction can lead to latency spikes or write stalls.

---

### **Advantages of LSM Trees and SSTables**

| Benefit                               | Explanation                                                       |
| ------------------------------------- | ----------------------------------------------------------------- |
| **High write throughput**             | Writes are sequential and append-only, ideal for SSDs/HDDs.       |
| **Efficient compression**             | Sorted immutable data compresses extremely well.                  |
| **Crash recovery is simple**          | WAL + immutable files ensure recoverability.                      |
| **Good scalability and distribution** | Works naturally with sharding, replication, and append-only logs. |

LSM-based databases often outperform B-tree systems in write-heavy distributed environments.

---

### **Disadvantages and Challenges**

| Limitation                | Explanation                                      |
| ------------------------- | ------------------------------------------------ |
| **Read amplification**    | Reads may require checking multiple SSTables.    |
| **Write amplification**   | Data is copied multiple times during compaction. |
| **Compaction overhead**   | Can cause latency spikes if not tuned.           |
| **Difficult range scans** | Possible, but sometimes slower than B-trees.     |

While LSM-Trees excel in write-heavy workloads, B-tree-based engines are often faster for read-heavy or mixed workloads without compaction overhead.

---

### **Real-World Use Cases**

LSM Trees are commonly used in:

* Logging pipelines
* Time-series databases
* Messaging systems (Kafka Streams RocksDB state)
* Distributed NoSQL key-value stores

Systems like **Cassandra and DynamoDB** rely on LSM designs to handle massive write loads across distributed clusters.

---

### **LSM Trees vs B-Trees (High-Level View)**

| Feature       | LSM Tree                      | B-Tree                      |
| ------------- | ----------------------------- | --------------------------- |
| Writes        | Append-only, sequential       | In-place page update        |
| Reads         | May require multi-file search | Fast point and range lookup |
| Compaction    | Required                      | Not required                |
| Range Queries | Slower (but possible)         | Very efficient              |
| Best Use Case | Write-heavy workloads         | Mix or read-heavy workloads |

This comparison explains why modern distributed systems prefer LSM-Trees, while traditional relational DBs still prefer B-tree storage.

---

### **Key Principle**

SSTables and LSM-Trees were designed to optimize writes by using sequential, immutable file structures combined with compaction. They trade off read complexity for exceptional write performance, durability, compression, and scalability. These structures form the backbone of many modern distributed and high-throughput databases.

