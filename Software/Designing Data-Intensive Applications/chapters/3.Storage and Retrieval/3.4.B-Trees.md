## **Topic 3.4 — B-Trees**

B-Trees are one of the most widely used indexing and storage structures in traditional databases. They are designed to maintain sorted data on disk while supporting efficient lookups, inserts, updates, and range scans. Unlike LSM-trees (which are optimized for sequential writes), B-trees support efficient **random reads and writes** while maintaining order — making them ideal for OLTP workloads.

B-Trees work by organizing data into fixed-size blocks or pages, typically matching the database's underlying storage block size (such as 4 KB or 8 KB). This alignment minimizes disk seeks and ensures efficient utilization of disk I/O. The tree structure ensures balance so that operations remain logarithmic in time complexity — generally **O(log n)** for reads, writes, and deletes.

---

### **Core Structure of a B-Tree**

A B-tree consists of multiple levels:

* **Root node**
* **Intermediate internal nodes**
* **Leaf nodes (where actual data lives)**

Every node contains:

* A sorted list of keys
* Pointers to child nodes or data pages

Nodes are sized to fill a full disk page, allowing efficient storage navigation.

Example simplified structure:

```
        [20 | 40 | 60]
        /     |      \
   [5 10]  [25 35]   [45 55 70]
```

This structure allows a key to be located by navigating downward, reducing the number of disk accesses.

---

### **Why B-Trees Work Well on Disk**

Disk and SSDs are slow at random access, but retrieving a full block at once is efficient. B-Trees minimize I/O by:

* Fetching large blocks at once
* Reducing tree height (logarithmic growth with high branching factor)
* Keeping frequently accessed pages cached in memory

As a result, most lookups require only **1–3 disk reads**, even with millions of records.

---

### **Insertion and Deletion in B-Trees**

When inserting a key:

1. The database locates the appropriate leaf node.
2. If there’s space, the key is inserted in sorted order.
3. If full, the node is **split** into two, and a key is promoted to the parent.

Deleting requires:

* Removing the key
* Possibly merging nodes if they fall below minimum occupancy

These operations ensure the tree remains balanced — unlike binary search trees, height never grows disproportionately.

---

### **Write-Ahead Log for Durability**

Because B-trees update nodes directly on disk (**update-in-place model**), power loss during modification can corrupt data. To prevent this, almost all B-tree–based systems use a:

* **Write-Ahead Log (WAL)** or **redo log**

The database first records intent in the log, then applies the change to the tree. On crash restart, the log ensures consistency.

Examples:

* **PostgreSQL Write-Ahead Log**
* **MySQL InnoDB redo/undo logs**
* **SQLite journal mode**

---

### **Optimizations and Variants**

There are multiple optimized versions of B-Trees:

* **B+ Trees** (most common):
  Leaf nodes store all data; internal nodes store only keys — improving range scan performance.

* **Fractal Trees (TokuDB)**:
  Add buffering to improve write throughput while retaining sorted order.

* **Clustered Indexes**:
  In engines like MySQL’s InnoDB, the primary key B-tree stores full rows; secondary indexes point to primary keys.

---

### **Strengths of B-Trees**

| Strength                        | Explanation                                      |
| ------------------------------- | ------------------------------------------------ |
| Efficient point lookups         | O(log n) access for `WHERE id = ?` queries       |
| Excellent range query support   | Sorted structure allows `BETWEEN`, index scans   |
| Stable read performance         | Consistent lookup time independent of table size |
| Mature and predictable behavior | Decades of tuning in relational databases        |

These characteristics make B-trees suitable for OLTP systems where reading and updating individual rows is frequent.

---

### **Limitations and Trade-offs**

| Limitation                          | Reason                                               |
| ----------------------------------- | ---------------------------------------------------- |
| High write amplification            | Splits, random writes, WAL persistence               |
| Performance degrades at large scale | Requires careful tuning for millions+ writes/sec     |
| Expensive for append-only workloads | Cannot match LSM sequential-write efficiency         |
| Harder distributed scaling          | In-place updates complicate replication and sharding |

Because B-trees modify data in place, consistency and durability mechanisms create overhead.

---

### **Comparing B-Trees with LSM Trees (Contextual)**

| Feature          | B-Tree                    | LSM Tree                 |
| ---------------- | ------------------------- | ------------------------ |
| Write style      | Update-in-place           | Append-only              |
| Write efficiency | Moderate                  | High                     |
| Read performance | Very good                 | Depends on compaction    |
| Range scans      | Excellent                 | Good but slower          |
| Compaction       | Not required              | Required                 |
| Best workloads   | Read-heavy, transactional | Write-heavy, distributed |

This explains why relational systems default to B-trees while distributed NoSQL systems often default to LSM-based storage.

---

### **Real-World Usage Examples**

B-tree indexing is used in:

* **PostgreSQL**
* **MySQL InnoDB**
* **SQLite**
* **Oracle**
* **Microsoft SQL Server**

Even file system metadata (like NTFS) and OS kernels use B-tree variants due to predictable disk access performance.

---

### **Key Principle**

B-Trees remain foundational for transactional, read-optimized database engines because they balance fast lookup, predictable cost, durability, and ordered access. While not as write-efficient as log-structured storage, their ordered structure and mature indexing capabilities make them indispensable in traditional relational and OLTP workloads.