## **Topic 7.2 — Weak Isolation Levels**

Weak isolation levels define *how much* interference is allowed between concurrently executing transactions.
Since strong isolation (serializability) can be expensive, many databases relax isolation for performance. This leads to **concurrency anomalies**, but increases throughput and reduces contention.

This topic covers:

* what weak isolation levels exist,
* how each works internally,
* the anomalies they allow,
* examples of real-world impact.

---

# **I. Why Weak Isolation Exists**

Strict serializable isolation makes transactions behave as if executed one-by-one.
But this can be slow due to:

* high locking contention,
* blocking between conflicting transactions,
* expensive validation,
* distributed coordination (in sharded systems).

To improve performance, databases introduce weaker isolation levels that allow some anomalies but maintain acceptable correctness for many workloads.

Weak isolation is a trade-off:

> **More performance → more anomalies**

---

# **II. Common Concurrency Anomalies**

Before explaining isolation levels, we define the anomalies they allow or prevent.

---

## **1. Dirty Reads**

A transaction sees **uncommitted** changes from another transaction.

```
T1: UPDATE account SET balance=0
T2: SELECT balance WHERE account=???
```

If T1 later rolls back → T2 has read incorrect data.

---

## **2. Dirty Writes**

Two transactions write to the same object concurrently before either commits.

This creates overwrites with undefined order.

---

## **3. Read Skew**

A transaction reads **two related values**, but sees them at different points in time.

Example:

* read account A balance
* other transaction transfers money
* read account B balance

Now the totals no longer match.

---

## **4. Lost Updates**

Two transactions read the same value and both update it.

```
T1: x = SELECT val
T2: x = SELECT val
T1: UPDATE val = x+1
T2: UPDATE val = x+1   ← T1's update overwritten
```

---

## **5. Write Skew**

A subtle anomaly where two transactions read overlapping keys but write to *different* keys, violating an invariant.

Example:
Two doctors must be on call.
Each sees the other as available → both mark themselves off-call → invariant violated.

---

## **6. Phantom Reads**

Rows appear or disappear during a transaction because another transaction inserts or deletes matching rows.

---

These anomalies are central to understanding weak isolation semantics.

---

# **III. Isolation Levels Defined by ANSI SQL**

ANSI SQL defines four weak isolation levels:

1. **Read Uncommitted**
2. **Read Committed**
3. **Repeatable Read**
4. **Serializable**

(Serializable is strong isolation, covered in Topic 7.3)

Most real-world DBs modify these definitions (e.g., PostgreSQL, Oracle, MySQL InnoDB).

---

# **IV. Read Uncommitted**

### **Definition**

The weakest isolation level:

> Transactions can read uncommitted writes from other transactions.

### **Allowed anomalies**

✔ Dirty reads
✔ Dirty writes
✔ Read skew
✔ Lost updates
✔ Write skew
✔ Phantom reads

### **Usage**

Almost never used in practice.
Even “read uncommitted” in many DBs is actually read-committed under the hood.

### **Real-world**

* MySQL InnoDB treats Read Uncommitted almost like Read Committed.
* Not useful except for analytics where stale data is acceptable.

---

# **V. Read Committed (Most Common Isolation Level)**

### **Definition**

> A transaction only reads data that has been committed.

### Prevents:

✔ Dirty reads
✔ Dirty writes

### Allows:

❌ Read skew
❌ Lost updates (unless locking used)
❌ Write skew
❌ Phantom reads

### How it is implemented?

* For reads: each SELECT sees the **latest committed version**.
* For writes: locks rows only during modification.

MVCC (Multi-Version Concurrency Control) helps ensure:

* Readers don't block writers,
* Writers don't block readers.

### Real-world examples:

* PostgreSQL default = Read Committed
* Oracle default = Read Committed
* SQL Server default = Read Committed

### Symptoms

Read skew is common:

```
T1: SELECT balance_A = 100
T2: UPDATE A = 0; COMMIT
T1: SELECT balance_A = 0   ← inconsistent snapshot
```

Repeated reads in the same transaction may change.

---

# **VI. Preventing Lost Updates in Read Committed**

Read committed *does not inherently prevent* lost updates.

To prevent lost updates:

* Explicit locks: `SELECT FOR UPDATE`
* Optimistic concurrency: compare and swap (CAS)
* Application-level version checks

---

# **VII. Snapshot Isolation (SI)**

Not part of ANSI SQL but widely used.
Very important modern isolation level.

### **Definition**

> Each transaction reads from a **consistent snapshot** of the database at its start time.

No matter how long the transaction runs, it sees a stable snapshot.

### Provides:

✔ No dirty reads
✔ No read skew
✔ Repeatable reads
✔ MVCC ensures minimal blocking

### Still allows:

❌ Write skew (very important!)
❌ Phantom reads (unless predicate locks are added)

### Example of write skew under SI

Two doctors on call:

```
T1 reads doctor A, doctor B → both on call
T2 reads doctor A, doctor B → both on call

T1 sets A off-call → OK
T2 sets B off-call → OK

Both commit → invariant violated
```

Snapshot isolation ≠ serializable.

### Real-world systems using SI

* PostgreSQL "Repeatable Read"
* Oracle
* MySQL (with InnoDB)
* SQL Server snapshot mode

Snapshot isolation is fast and popular, but unsafe for invariant-based logic.

---

# **VIII. Repeatable Read (ANSI SQL)**

Definition in ANSI:

> Same row read twice must return same value.

But real-world interpretation varies.

### Prevents:

✔ Dirty reads
✔ Non-repeatable reads
✔ Lost updates (sometimes)

### Still allows:

❌ Phantom reads
❌ Write skew

### Real-world differences:

* PostgreSQL’s “Repeatable Read” = actually Snapshot Isolation
* MySQL InnoDB’s “Repeatable Read” = snapshot isolation + gap locks (reducing phantoms)

This inconsistency across DB engines is a major source of developer confusion.

---

# **IX. Summary Table of Isolation Levels**

| Isolation Level    | Dirty Read | Read Skew | Lost Update | Write Skew | Phantom | Notes               |
| ------------------ | ---------- | --------- | ----------- | ---------- | ------- | ------------------- |
| Read Uncommitted   | Yes        | Yes       | Yes         | Yes        | Yes     | Almost never used   |
| Read Committed     | No         | Yes       | Yes         | Yes        | Yes     | Most common default |
| Snapshot Isolation | No         | No        | Prevented   | Yes        | Yes     | Very popular        |
| Repeatable Read    | No         | No        | Sometimes   | Yes        | Yes/No  | Impl varies         |
| Serializable       | No         | No        | No          | No         | No      | Strongest           |

---

# **X. Why Weak Isolation Still Matters**

Weak isolation levels exist because:

1. **Performance benefits**

   * fewer locks
   * less blocking
   * fewer aborts
   * higher throughput

2. **Many applications do not need full serializability**

   * analytics
   * reporting
   * metrics dashboards
   * simple CRUD apps

3. **Distributed systems complexity**
   Serializable isolation across shards is expensive; weaker levels scale better.

---

# **XI. Isolation Levels in Distributed Systems**

Distributed DBs often choose weaker isolation for scalability.

### Examples:

* **Cassandra**: no full transactions, eventual consistency, LWT for strong conditional writes.
* **DynamoDB**: per-item ACID only.
* **MongoDB**: document-level transactions (multi-document allowed since v4.0).
* **CockroachDB**: full serializable isolation using MVCC + timestamp ordering.

Weak isolation levels can be amplified or worsened by:

* replication lag
* stale reads from followers
* network partitions

These create phenomena similar to read skew or write skew even without concurrency.

---

# **XII. Key Takeaways for Topic 7.2**

### **1. Weak isolation is a performance optimization.**

It allows concurrency but permits anomalies.

### **2. Isolation levels vary dramatically across databases.**

Real-world implementations differ from ANSI definitions.

### **3. Snapshot Isolation is powerful but unsafe for complex invariants.**

Write skew is a common, subtle anomaly.

### **4. Most real systems default to Read Committed.**

### **5. Anomalies like read skew, lost updates, phantoms, and write skew must be understood by engineers.**

### **6. Serializable isolation is the only truly safe isolation level—but expensive.**