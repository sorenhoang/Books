## **Topic 7.1 — The Concept of a Transaction**

Transactions are a foundational abstraction in databases that make it easier for application developers to reason about correctness—even when things go wrong due to **concurrency**, **crashes**, **network issues**, or **partial failures**.

This topic explains **what transactions are**, **why they exist**, and **how they protect data integrity**.

---

# **I. Why Do We Need Transactions?**

Real-world applications perform multi-step operations:

* Deduct money from one account and add to another
* Update inventory when an order is placed
* Insert a new user and related records
* Write multiple pieces of state that must stay in sync

Without transactions, failures in the middle of such operations can cause:

* partial updates
* data corruption
* inconsistent states
* double-charging or under-charging
* race conditions

Transactions simplify all this by encapsulating multiple operations into a **single unit of work**.

---

# **II. The Four Elements of Transactions: ACID**

Transactions are traditionally defined by **ACID**:

---

## **1. Atomicity**

> **The transaction is “all or nothing.”**

If a transaction fails halfway, all its intermediate effects must be rolled back.
This prevents partial updates or inconsistent states.

Examples:

* Money deducted from account A but not added to B.
* A record inserted without its related entries.

Atomicity ensures that these incomplete results never become visible.

---

## **2. Consistency**

> **The system moves from one valid state to another valid state.**

Consistency refers to **application-level invariants**, not the same as consistency in CAP.

Example invariants:

* Account balances cannot be negative.
* Foreign keys must match.
* Unique constraints must be upheld.

If constraints are violated, the transaction must abort.

---

## **3. Isolation**

> **Concurrent transactions should not interfere with each other.**

Without isolation:

* Dirty reads
* Lost updates
* Write-write conflicts
* Read skew / write skew

Isolation makes transactions *behave as if they were executed sequentially*, even when run in parallel.

---

## **4. Durability**

> **Once a transaction commits, its results must persist—even if the system crashes.**

Durability typically relies on:

* Write-ahead logs (WAL)
* Replication
* Checkpointing
* Persistent storage

Once `COMMIT` succeeds, data will survive failures.

---

# **III. What Does “Correctness” Mean in Concurrent Systems?**

Transactions simplify correctness by ensuring:

* No partial writes
* No corrupt intermediate state
* No inconsistent reads
* No lost updates

Even under:

* concurrency,
* hardware crashes,
* network partitions,
* power failures.

Because of this, transactions remove many burdens from application developers.

---

# **IV. Application Scenarios Where Transactions Matter**

### **1. Banking / Financial Transfers**

A transfer should only succeed if:

* Account A was debited
* Account B was credited
* Neither account went negative

Any failure at any step must roll back everything.

---

### **2. E-commerce**

Order placement requires:

* Checking inventory
* Deducting stock
* Creating order record
* Charging payment

If payment fails, inventory deduction must roll back.

---

### **3. Messaging / Event Systems**

Message must be:

* appended once
* not duplicated
* not lost
* not visible before fully written

---

### **4. User Creation**

User records may span:

* authentication table
* profile table
* preferences table

Transaction ensures they are consistent.

---

# **V. Transactions as an Abstraction Layer**

Developers prefer transactions because they hide complexity. Internally, databases must handle:

* multiple concurrent operations
* locks or MVCC
* logging
* crash recovery
* replication
* consensus
* distributed writes

Transactions give a **clean and simple interface**:

```
BEGIN
  UPDATE ...
  INSERT ...
COMMIT
```

The database handles all edge cases internally.

---

# **VI. Single-Object vs Multi-Object Operations**

Some operations involve just one key/value pair:

* incrementing a counter
* reading/writing a row

These can often be made atomic without full ACID transactions.

### More complex operations span multiple objects:

* multiple rows in SQL
* multiple documents in MongoDB
* multiple partitions in a distributed system

These require real ACID transactions or a distributed transaction protocol.

---

# **VII. Broken Assumptions Without Transactions**

If transactions didn't exist, developers would need to manually code:

* retries for failures
* rollback logic
* concurrency conflict detection
* maintaining intermediate copies
* ensuring uniqueness constraints

This is error-prone and brittle.

Example:

* two users booking the last hotel room at the same time
* two requests modifying the same account balance concurrently

Transactions formalize these concerns and avoid race conditions.

---

# **VIII. Transactions in Distributed Systems**

Modern databases often run across multiple machines.
Transactions across nodes require:

* consensus (e.g., Raft, Paxos)
* two-phase commit (2PC)
* careful replication coordination
* timeout handling
* detecting coordinator failure
* fencing tokens

Distributed transactions are more expensive but essential when a single logical operation spans multiple shards.

---

# **IX. Guarantees and Limitations of Transactions**

### **Transactions guarantee:**

* atomicity
* isolation (based on isolation level)
* durability

### **Transactions do NOT guarantee:**

* correctness of application logic
* protection from associating wrong data
* protection from bad partitioning strategies
* protection from high latencies under load

Transactions help but do not solve all distributed system problems.

---

# **X. Common Misconceptions**

### **1. “Consistency” in ACID = CAP consistency” — wrong.**

* ACID consistency → invariants
* CAP consistency → linearizability

### **2. “Transactions eliminate all anomalies.”**

Only if **serializable isolation** is used.

### **3. “Transactions are always expensive.”**

Modern techniques like:

* MVCC
* optimistic concurrency control
* lock-free data structures
  make transactions efficient.

---

# **XI. Key Takeaways for Topic 7.1**

### **1. Transactions group multiple operations into a single, safe unit.**

They guarantee correctness even under failures.

### **2. ACID formalizes four core properties:**

* Atomicity
* Consistency
* Isolation
* Durability

### **3. Without transactions, developers must handle edge cases manually.**

### **4. Isolation protects from concurrency anomalies.**

### **5. Durability protects from crashes.**

### **6. Distributed transactions add complexity but are essential in sharded systems.**

### **7. Transactions simplify reasoning about correctness in complicated, failure-prone environments.**
