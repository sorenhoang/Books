## **Topic 7.5 — Summary**

This summary brings together the major ideas from **Chapter 7 — Transactions**, highlighting the meaning, purpose, and implementation of transactions, along with the trade-offs between different isolation levels. It captures all essential concepts needed for system design and database engineering.

---

# **I. The Role of Transactions**

Transactions are a critical tool for managing **concurrency**, **failures**, and **data integrity** in databases. They provide a clean abstraction that helps developers avoid subtle bugs when multiple operations must happen together.

A transaction groups multiple reads/writes into a **single atomic unit** that either:

✔ completes successfully
✘ or has no effect at all

---

# **II. ACID Properties Recap**

Transactions are defined by **ACID**:

### **1. Atomicity** — all or nothing

Intermediate states never become visible. If a failure occurs, the system rolls back changes.

### **2. Consistency** — respects application invariants

Constraints like foreign keys, uniqueness, or business logic must hold before and after a transaction.

### **3. Isolation** — prevents interference

Transactions should behave as if they ran sequentially, depending on isolation level.

### **4. Durability** — committed changes survive crashes

Accomplished via WAL, replication, checkpoints.

These properties simplify complex multi-step logic.

---

# **III. Weak Isolation Levels**

Most databases do **not** use serializable isolation by default because it is expensive. To improve performance, they offer weaker levels that avoid some anomalies but allow others.

### **Read Uncommitted**

* Can see uncommitted data
* Almost never used

### **Read Committed** *(most common default)*

* No dirty reads
* But allows read skew and lost updates

### **Snapshot Isolation (SI)**

* Reads see a consistent snapshot
* Prevents many anomalies
* Still allows **write skew** (big issue)

### **Repeatable Read**

* Prevents non-repeatable reads
* Implementation varies by database
* MySQL + gap locks reduce phantoms

Weak isolation improves performance but requires developers to understand potential anomalies (lost updates, write skew, phantom reads).

---

# **IV. Serializable Isolation — The Gold Standard**

Serializable isolation ensures:

> **Concurrent transactions behave exactly as if executed in some sequential order.**

Serializable prevents **all anomalies**:

* dirty reads
* read skew
* write skew
* phantom reads
* lost updates

Serializable isolation gives developers the strongest guarantee—but at a cost.

### How serializable is implemented:

#### **1. Strict 2-Phase Locking (2PL)**

* Pessimistic
* Blocks reads
* Causes deadlocks

#### **2. Serializable Snapshot Isolation (SSI)**

* Optimistic
* Uses MVCC
* Detects dangerous dependency cycles
* Aborts conflicting transactions

Used by PostgreSQL and CockroachDB.

#### **3. Deterministic execution (Calvin, FoundationDB)**

* Pre-order transactions
* Execute deterministically
* Avoids concurrency anomalies by construction

---

# **V. Performance vs Correctness Trade-offs**

Serializable isolation is safest but can reduce throughput because it requires:

* conflict detection,
* more metadata tracking,
* more aborts,
* strict ordering,
* blocking operations (in 2PL systems).

Weaker isolation levels exist to balance these costs.

### Key insights from Chapter 7:

* **Isolation has a huge impact on performance.**
* **Optimistic methods (like SSI) work well with MVCC and read-heavy workloads.**
* **Pessimistic methods work better when contention is high.**
* **Distributed serializability is much harder** due to clock sync, cross-shard dependencies, failovers, etc.

Systems like Spanner and CockroachDB use complex algorithms to enforce serializability across global clusters.

---

# **VI. Distributed Transaction Challenges**

In distributed databases, serializable transactions add complexity:

* 2PC (two-phase commit)
* timestamp ordering
* consensus protocols
* fencing tokens
* commit-wait
* replication delays

Achieving serializability across partitions is expensive but important in correctness-critical workloads.

---

# **VII. When Transactions Are Essential**

Transactions should be used when:

✔ business invariants matter
✔ operations depend on multiple steps
✔ concurrency is unpredictable
✔ failures must not cause corruption
✔ correctness is more important than raw performance

Examples:

* finance
* inventory
* state transitions
* account management
* system of record databases

---

# **VIII. When Weaker Isolation Is Acceptable**

Weak isolation is fine when:

✔ data is ephemeral
✔ eventual consistency is acceptable
✔ system tolerates anomalies
✔ throughput is more important than exact ordering

Examples:

* analytics
* logs
* metrics
* caches
* shopping cart events (with CRDTs or idempotency)

Understanding workload patterns helps choose the right isolation level.

---

# **IX. Key Lessons from Chapter 7**

### **1. Transactions protect against concurrency anomalies and system failures.**

They provide a clean abstraction that hides internal complexity.

### **2. ACID is critical for correctness but not universally required.**

### **3. Weak isolation levels are performance optimizations.**

But developers must understand the anomalies they allow.

### **4. Snapshot Isolation is very popular but NOT serializable.**

Write skew is a major pitfall.

### **5. Serializable isolation is safest but expensive.**

Especially in distributed systems.

### **6. Modern serializable implementations rely on MVCC + optimistic validation.**

### **7. Distributed ACID transactions require complex coordination.**

### **8. Understanding isolation levels is essential for designing correct, scalable systems.**