## **Topic 7.3 — Serializable Isolation**

Serializable isolation is the **strongest, safest, and most intuitive** isolation level. It ensures that **concurrent transactions behave exactly as if they were executed one at a time**, in some order, without any overlap.

This topic explains:

* what serializability means,
* why weaker levels fail,
* how databases *actually* implement serializability,
* differences between **pessimistic** and **optimistic** approaches,
* and how modern systems achieve serializability efficiently.

---

# **I. What Does “Serializable” Mean?**

Serializable = **the gold standard** of transaction isolation.

### Formal definition:

> **The outcome of executing transactions concurrently is the same as if the transactions were executed in some serial order.**

Even if transactions overlap in time, the *result* must be equivalent to some sequential ordering.

### Why this matters?

* Avoids all anomalies from Topic 7.2
* Guarantees correctness for all application invariants
* Makes reasoning about concurrency trivial

If your application logic assumes serial execution, serializability ensures that is always safe.

---

# **II. What Serializable Isolation Prevents**

Serializable isolation prevents **all** anomalies:

| Anomaly                   | Prevented?                           |
| ------------------------- | ------------------------------------ |
| Dirty reads               | ✔                                    |
| Non-repeatable reads      | ✔                                    |
| Read skew                 | ✔                                    |
| Write skew                | ✔                                    |
| Lost updates              | ✔                                    |
| Phantom reads             | ✔                                    |
| All constraint violations | ✔ (if constraints modeled correctly) |

Serializable isolation eliminates subtle race conditions that snapshot isolation still allows.

---

# **III. Why Serializable Isolation Is Hard**

Serializability requires the system to detect and block or abort dangerous interleavings.

Challenges:

* Identifying conflicts in real-time
* Coordinating constraints across multiple keys
* Handling transactions that touch many partitions
* Avoiding deadlocks
* Guaranteeing correctness without sacrificing performance

Yet modern databases (e.g., PostgreSQL, CockroachDB) have managed to implement serializable isolation in surprisingly efficient ways.

---

# **IV. Approaches to Implementing Serializable Isolation**

There are three families of implementation:

---

# **1. Strict Two-Phase Locking (S2PL)**

(*Pessimistic concurrency control*)

### How it works:

* A transaction must acquire locks before reading or writing.
* Locks are held **until commit**.
* No new locks may be acquired after releasing any lock.

This ensures no conflicting operations overlap.

### Advantages

✔ Strong guarantee (true serializability)
✔ Good for workloads with high write contention

### Disadvantages

❌ Deadlocks
❌ Blocking when reads wait for writes
❌ Reduced throughput
❌ Poor performance in distributed systems

### Used in:

* Older databases
* Some OLTP systems
* MySQL with `SERIALIZABLE` mode (uses predicate locks)

Strict 2PL is robust but heavy-handed.

---

# **2. Serializable Snapshot Isolation (SSI)**

(*Optimistic concurrency control on top of MVCC*)

Modern approach introduced by PostgreSQL and adopted in CockroachDB.

### Key idea:

Transactions read from a snapshot (MVCC) but are also monitored for **dangerous patterns** that could lead to non-serializable behavior.

Instead of locking everything:

* Transactions run concurrently under snapshot isolation
* System tracks read/write dependencies
* If a dangerous dependency cycle is detected → **abort one transaction**

SSI prevents anomalies like write skew without using 2PL.

### Advantages

✔ Non-blocking reads (thanks to MVCC)
✔ Fewer deadlocks
✔ High throughput
✔ Good in distributed systems

### Disadvantages

❌ More transaction aborts
❌ More metadata tracking
❌ Complex to implement

### Used in:

* PostgreSQL `SERIALIZABLE` isolation
* CockroachDB (fully serializable default)

SSI is now considered the best practical implementation of serializable isolation for general workloads.

---

# **3. Deterministic / Ordered Execution**

(*Calvin-style deterministic databases*)

### How it works:

* All transactions are pre-ordered via a global transaction log.
* Execution is deterministic across nodes.
* System guarantees serial order by construction.

### Advantages

✔ Perfect serializability
✔ High throughput once transactions are batched
✔ Great for distributed settings (no coordination during execution)

### Disadvantages

❌ Requires predictable transaction logic
❌ High latency in low-throughput workloads
❌ Not suited for ad-hoc queries

### Used in:

* Calvin
* FaRM
* FoundationDB
* Dolt (MVCC + deterministic commit)

This approach avoids concurrency problems entirely.

---

# **V. Serializable Isolation in Practice**

Serializable isolation in real databases varies.

---

## **PostgreSQL**

Uses **Serializable Snapshot Isolation (SSI)**:

* Runs transactions as snapshot-isolated
* Detects dependency cycles
* Aborts offending transactions
* Guarantees serializable correctness

---

## **MySQL (InnoDB)**

`SERIALIZABLE` uses **2PL-like behavior**:

* Converts reads into `SELECT LOCK IN SHARE MODE`
* Prevents phantoms by locking index gaps
* Essentially pessimistic locking

---

## **Oracle**

Uses a mixture of MVCC with locking for predicates. Serializable mode prohibits some operations entirely.

---

## **CockroachDB**

Serializable by default using:

* MVCC timestamps
* Read and write spans
* Timestamp cache
* Retry loops
* Commit-wait protocol

Extremely strong guarantees even across multiple partitions.

---

## **Spanner**

Provides strict serializable isolation globally using:

* TrueTime clock synchronization
* Synchronized writes
* MVCC
* Commit-wait based on time uncertainty

Spanner is serializable, externally consistent (stronger than serializable).

---

# **VI. Why Snapshot Isolation Is Not Serializable**

Snapshot isolation prevents many anomalies but allows **write skew**, which can break invariants.

Example (doctors on call):

```
T1 reads A=on, B=on
T2 reads A=on, B=on

T1 sets A=off
T2 sets B=off
```

Both commit with no conflict → constraint violated.

Serializable isolation avoids this by:

* detecting dangerous dependency patterns (SSI), or
* locking predicates (2PL), or
* ordering transactions (Calvin).

This is the major difference.

---

# **VII. Trade-Offs Between SSI and 2PL**

| Feature        | SSI (Optimistic)      | 2PL (Pessimistic)      |
| -------------- | --------------------- | ---------------------- |
| Reads block?   | No                    | Yes (can block)        |
| Deadlocks?     | No                    | Yes                    |
| Abort rate     | Higher                | Lower                  |
| Performance    | Higher for read-heavy | Better for write-heavy |
| Implementation | Complex               | Simpler conceptually   |

Most modern systems choose **SSI**, except in highly-contentious workloads.

---

# **VIII. Serializable Across Partitions (Distributed TXNs)**

In a distributed database:

* A transaction may touch multiple partitions.
* Each partition has its own timestamp or lock manager.
* Coordination overhead increases dramatically.

Serializable distributed isolation requires:

### ✔ Multi-partition conflict detection

### ✔ Two-phase commit (2PC) for atomicity

### ✔ Consensus (Raft/Paxos) for replication

### ✔ MVCC timestamp ordering

Systems like CockroachDB and Spanner achieve this but at significant engineering cost.

---

# **IX. Serializable ≠ Linearizable**

These terms are often confused.

### **Serializable**

* Guarantees correctness of *transactions*.
* Does not impose real-time ordering constraints.

### **Linearizable**

* Stronger than serializable.
* Guarantees that operations respect real-world time.
* Typically applied to **single-object reads/writes**, not full transactions.

Spanner provides **both**.

---

# **X. When Should You Use Serializable Isolation?**

Use serializable isolation when:

### ✔ Correctness matters more than performance

(e.g., financial, inventory, state machine transitions)

### ✔ Business invariants involve multiple objects

(e.g., “At least one doctor must be on call”)

### ✔ You need guaranteed protection from subtle race conditions

Serializable isolation is **overkill** when:

### ❌ Analytical queries

### ❌ Log ingestion

### ❌ Idempotent writes

### ❌ Low-value data

### ❌ Massive high-throughput workloads with simple invariants

---

# **XI. Key Takeaways for Topic 7.3**

### **1. Serializable = strongest, safest isolation level.**

### **2. Prevents ALL anomalies:**

* lost updates
* write skew
* read skew
* phantom reads
* dirty reads/writes

### **3. Three main implementation strategies:**

* **2PL** (locking)
* **SSI** (optimistic MVCC)
* **Deterministic execution** (ordering transactions)

### **4. SSI is the modern preferred method**

Used in PostgreSQL and CockroachDB.

### **5. Serializable is expensive but essential for correctness-critical workloads.**

### **6. Distributed serializability requires careful coordination across shards.**